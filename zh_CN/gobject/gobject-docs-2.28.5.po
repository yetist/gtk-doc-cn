#
# Translators:
# antkillerfarm <antkillerfarm@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: GObject Reference Manual\n"
"Report-Msgid-Bugs-To: http://code.google.com/p/gtk-doc-cn/issues\n"
"POT-Creation-Date: 2011-04-17 23:55+0800\n"
"PO-Revision-Date: 2015-06-22 08:00+0000\n"
"Last-Translator: antkillerfarm <antkillerfarm@gmail.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/projects/p/gobject-"
"reference-manual/language/zh_CN/)\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: glib-genmarshal.xml:0(None) glib-mkenums.xml:0(None)
#: gobject-docs.sgml:0(None) gobject-query.xml:0(None) tut_gobject.xml:0(None)
#: tut_gsignal.xml:0(None) tut_gtype.xml:0(None) tut_howto.xml:0(None)
#: tut_intro.xml:0(None) tut_tools.xml:0(None)
msgid "translator-credits"
msgstr ""
"Ant Killer<antkillerfarm@gmail.com>,2013\"\n"
"\"图拉鼎<tualatrix@gmail.com>,2008"

#: glib-genmarshal.xml:10(refname) glib-genmarshal.xml:16(command)
#: glib-genmarshal.xml:4(refentrytitle) glib-mkenums.xml:289(refentrytitle)
msgid "glib-genmarshal"
msgstr ""

#: glib-genmarshal.xml:103(title)
msgid "Marshaller list format"
msgstr ""

#: glib-genmarshal.xml:104(para)
msgid ""
"The marshaller lists are processed line by line, a line can contain a "
"comment in the form of <placeholder-1/> or a marshaller specification of the "
"form <placeholder-2/> (up to 16 <replaceable>PTYPE</replaceable>s may be "
"present)."
msgstr ""

#: glib-genmarshal.xml:107(programlisting)
#, no-wrap
msgid ""
"\n"
"# this is a comment\n"
msgstr ""

#: glib-genmarshal.xml:11(refpurpose)
msgid "C code marshaller generation utility for GLib closures"
msgstr ""

#: glib-genmarshal.xml:111(programlisting)
#, no-wrap
msgid ""
"\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>\n"
msgstr ""

#: glib-genmarshal.xml:118(para)
msgid ""
"The <replaceable>RTYPE</replaceable> part specifies the callback's return "
"type and the <replaceable>PTYPE</replaceable>s right to the colon specify "
"the callback's parameter list, except for the first and the last arguments "
"which are always pointers."
msgstr ""

#: glib-genmarshal.xml:125(title)
msgid "Parameter types"
msgstr ""

#: glib-genmarshal.xml:126(para)
msgid "Currently, the following types are supported: <placeholder-1/>"
msgstr ""

#: glib-genmarshal.xml:130(replaceable)
msgid "VOID"
msgstr ""

#: glib-genmarshal.xml:131(para)
msgid ""
"indicates no return type, or no extra parameters. If <replaceable>VOID</"
"replaceable> is used as the parameter list, no additional parameters may be "
"present."
msgstr ""

#: glib-genmarshal.xml:139(replaceable)
msgid "BOOLEAN"
msgstr ""

#: glib-genmarshal.xml:140(para)
msgid "for boolean types (gboolean)"
msgstr ""

#: glib-genmarshal.xml:146(replaceable)
msgid "CHAR"
msgstr ""

#: glib-genmarshal.xml:147(para)
msgid "for signed char types (gchar)"
msgstr ""

#: glib-genmarshal.xml:153(replaceable)
msgid "UCHAR"
msgstr ""

#: glib-genmarshal.xml:154(para)
msgid "for unsigned char types (guchar)"
msgstr ""

#: glib-genmarshal.xml:160(replaceable)
msgid "INT"
msgstr ""

#: glib-genmarshal.xml:161(para)
msgid "for signed integer types (gint)"
msgstr ""

#: glib-genmarshal.xml:167(replaceable)
msgid "UINT"
msgstr ""

#: glib-genmarshal.xml:168(para)
msgid "for unsigned integer types (guint)"
msgstr ""

#: glib-genmarshal.xml:17(arg) glib-mkenums.xml:17(arg)
#: gobject-query.xml:18(arg) gobject-query.xml:23(arg)
msgid "options"
msgstr ""

#: glib-genmarshal.xml:174(replaceable)
msgid "LONG"
msgstr ""

#: glib-genmarshal.xml:175(para)
msgid "for signed long integer types (glong)"
msgstr ""

#: glib-genmarshal.xml:18(arg) glib-mkenums.xml:18(arg)
msgid "files"
msgstr ""

#: glib-genmarshal.xml:181(replaceable)
msgid "ULONG"
msgstr ""

#: glib-genmarshal.xml:182(para)
msgid "for unsigned long integer types (gulong)"
msgstr ""

#: glib-genmarshal.xml:188(replaceable)
msgid "INT64"
msgstr ""

#: glib-genmarshal.xml:189(para)
msgid "for signed 64bit integer types (gint64)"
msgstr ""

#: glib-genmarshal.xml:195(replaceable)
msgid "UINT64"
msgstr ""

#: glib-genmarshal.xml:196(para)
msgid "for unsigned 64bit integer types (guint64)"
msgstr ""

#: glib-genmarshal.xml:202(replaceable)
msgid "ENUM"
msgstr ""

#: glib-genmarshal.xml:203(para)
msgid "for enumeration types (gint)"
msgstr ""

#: glib-genmarshal.xml:209(replaceable)
msgid "FLAGS"
msgstr ""

#: glib-genmarshal.xml:210(para)
msgid "for flag enumeration types (guint)"
msgstr ""

#: glib-genmarshal.xml:216(replaceable)
msgid "FLOAT"
msgstr ""

#: glib-genmarshal.xml:217(para)
msgid "for single-precision float types (gfloat)"
msgstr ""

#: glib-genmarshal.xml:22(title) glib-mkenums.xml:22(title)
#: gobject-query.xml:27(title)
msgid "Description"
msgstr ""

#: glib-genmarshal.xml:223(replaceable)
msgid "DOUBLE"
msgstr ""

#: glib-genmarshal.xml:224(para)
msgid "for double-precision float types (gdouble)"
msgstr ""

#: glib-genmarshal.xml:23(para)
msgid ""
"<command>glib-genmarshal</command> is a small utility that generates C code "
"marshallers for callback functions of the GClosure mechanism in the GObject "
"sublibrary of GLib. The marshaller functions have a standard signature, they "
"get passed in the invoking closure, an array of value structures holding the "
"callback function parameters and a value structure for the return value of "
"the callback. The marshaller is then responsible to call the respective C "
"code function of the closure with all the parameters on the stack and to "
"collect its return value."
msgstr ""

#: glib-genmarshal.xml:230(replaceable)
msgid "STRING"
msgstr ""

#: glib-genmarshal.xml:231(para)
msgid "for string types (gchar*)"
msgstr ""

#: glib-genmarshal.xml:237(replaceable)
msgid "BOXED"
msgstr ""

#: glib-genmarshal.xml:238(para)
msgid "for boxed (anonymous but reference counted) types (GBoxed*)"
msgstr ""

#: glib-genmarshal.xml:244(replaceable)
msgid "PARAM"
msgstr ""

#: glib-genmarshal.xml:245(para)
msgid "for GParamSpec or derived types (GParamSpec*)"
msgstr ""

#: glib-genmarshal.xml:251(replaceable)
msgid "POINTER"
msgstr ""

#: glib-genmarshal.xml:252(para)
msgid "for anonymous pointer types (gpointer)"
msgstr ""

#: glib-genmarshal.xml:258(replaceable)
msgid "OBJECT"
msgstr ""

#: glib-genmarshal.xml:259(para)
msgid "for GObject or derived types (GObject*)"
msgstr ""

#: glib-genmarshal.xml:265(replaceable)
msgid "VARIANT"
msgstr ""

#: glib-genmarshal.xml:266(para)
msgid "for GVariant types (GVariant*)"
msgstr ""

#: glib-genmarshal.xml:272(replaceable)
msgid "NONE"
msgstr ""

#: glib-genmarshal.xml:273(para)
msgid "deprecated alias for <replaceable>VOID</replaceable>"
msgstr ""

#: glib-genmarshal.xml:279(replaceable)
msgid "BOOL"
msgstr ""

#: glib-genmarshal.xml:280(para)
msgid "deprecated alias for <replaceable>BOOLEAN</replaceable>"
msgstr ""

#: glib-genmarshal.xml:288(title)
msgid "Example"
msgstr ""

#: glib-genmarshal.xml:289(para)
msgid "To generate marshallers for the following callback functions:"
msgstr ""

#: glib-genmarshal.xml:292(programlisting)
#, no-wrap
msgid ""
"\n"
"void   foo (gpointer data1,\n"
"            gpointer data2);\n"
"void   bar (gpointer data1,\n"
"            gint     param1,\n"
"            gpointer data2);\n"
"gfloat baz (gpointer data1,\n"
"            gboolean param1,\n"
"            guchar   param2,\n"
"            gpointer data2);\n"
msgstr ""

#: glib-genmarshal.xml:303(para)
msgid "The marshaller list has to look like this:"
msgstr ""

#: glib-genmarshal.xml:306(programlisting)
#, no-wrap
msgid ""
"\n"
"VOID:VOID\n"
"VOID:INT\n"
"FLOAT:BOOLEAN,UCHAR\n"
msgstr ""

#: glib-genmarshal.xml:311(para)
msgid ""
"The generated marshallers have the arguments encoded in their function name. "
"For this particular list, they are"
msgstr ""

#: glib-genmarshal.xml:315(programlisting)
#, no-wrap
msgid ""
"\n"
"g_cclosure_marshal_VOID__VOID(),\n"
"g_cclosure_marshal_VOID__INT(), \n"
"g_cclosure_marshal_FLOAT__BOOLEAN_UCHAR().\n"
msgstr ""

#: glib-genmarshal.xml:320(para)
msgid ""
"They can be used directly for GClosures or be passed in as the "
"GSignalCMarshaller c_marshaller; argument upon creation of signals:"
msgstr ""

#: glib-genmarshal.xml:324(programlisting)
#, no-wrap
msgid ""
"\n"
"GClosure *cc_foo, *cc_bar, *cc_baz;\n"
"\n"
"cc_foo = g_cclosure_new (NULL, foo, NULL);\n"
"g_closure_set_marshal (cc_foo, g_cclosure_marshal_VOID__VOID);\n"
"cc_bar = g_cclosure_new (NULL, bar, NULL);\n"
"g_closure_set_marshal (cc_bar, g_cclosure_marshal_VOID__INT);\n"
"cc_baz = g_cclosure_new (NULL, baz, NULL);\n"
"g_closure_set_marshal (cc_baz, g_cclosure_marshal_FLOAT__BOOLEAN_UCHAR);\n"
msgstr ""

#: glib-genmarshal.xml:335(title) glib-mkenums.xml:286(title)
msgid "See also"
msgstr ""

#: glib-genmarshal.xml:336(para)
msgid "<command>glib-mkenums</command>(1)"
msgstr ""

#: glib-genmarshal.xml:34(title) glib-mkenums.xml:31(title)
#: gobject-query.xml:34(title)
msgid "Invocation"
msgstr ""

#: glib-genmarshal.xml:340(title)
msgid "Bugs"
msgstr ""

#: glib-genmarshal.xml:341(para)
msgid "None known yet."
msgstr ""

#: glib-genmarshal.xml:345(title)
msgid "Author"
msgstr ""

#: glib-genmarshal.xml:346(para)
msgid ""
"<command>glib-genmarshal</command> has been written by Tim Janik "
"<email>timj@gtk.org</email>."
msgstr ""

#: glib-genmarshal.xml:349(para)
msgid "This manual page was provided by Tim Janik <email>timj@gtk.org</email>."
msgstr ""

#: glib-genmarshal.xml:35(para)
msgid ""
"<command>glib-genmarshal</command> takes a list of marshallers to generate "
"as input. The marshaller list is either read from standard input or from "
"files passed as additional arguments on the command line."
msgstr ""

#: glib-genmarshal.xml:40(title) glib-mkenums.xml:38(title)
#: gobject-query.xml:40(title)
msgid "Options"
msgstr ""

#: glib-genmarshal.xml:44(option)
msgid "--header"
msgstr ""

#: glib-genmarshal.xml:45(para)
msgid "Generate header file contents of the marshallers."
msgstr ""

#: glib-genmarshal.xml:5(manvolnum) glib-mkenums.xml:290(manvolnum)
#: glib-mkenums.xml:5(manvolnum) gobject-query.xml:5(manvolnum)
msgid "1"
msgstr ""

#: glib-genmarshal.xml:51(option)
msgid "--body"
msgstr ""

#: glib-genmarshal.xml:52(para)
msgid "Generate C code file contents of the marshallers."
msgstr ""

#: glib-genmarshal.xml:58(term)
msgid "<option>--prefix=string</option>, <option>--prefix string</option>"
msgstr ""

#: glib-genmarshal.xml:59(para)
msgid ""
"Specify marshaller prefix. The default prefix is "
"<literal>`g_cclosure_marshal'</literal>."
msgstr ""

#: glib-genmarshal.xml:6(refmiscinfo) glib-mkenums.xml:6(refmiscinfo)
#: gobject-query.xml:6(refmiscinfo)
msgid "User Commands"
msgstr ""

#: glib-genmarshal.xml:65(option)
msgid "--skip-source"
msgstr ""

#: glib-genmarshal.xml:66(para)
msgid "Skip source location remarks in generated comments."
msgstr ""

#: glib-genmarshal.xml:72(option)
msgid "--nostdinc"
msgstr ""

#: glib-genmarshal.xml:73(para)
msgid ""
"Do not use the standard marshallers of the GObject library, and skip "
"<filename>gmarshal.h</filename> include directive in generated header files."
msgstr ""

#: glib-genmarshal.xml:80(option)
msgid "--g-fatal-warnings"
msgstr ""

#: glib-genmarshal.xml:81(para)
msgid "Make warnings fatal, that is, exit immediately once a warning occurs."
msgstr ""

#: glib-genmarshal.xml:87(term) gobject-query.xml:94(term)
msgid "<option>-h</option>, <option>--help</option>"
msgstr ""

#: glib-genmarshal.xml:88(para) glib-mkenums.xml:122(para)
#: gobject-query.xml:95(para)
msgid "Print brief help and exit."
msgstr ""

#: glib-genmarshal.xml:94(term) gobject-query.xml:101(term)
msgid "<option>-v</option>, <option>--version</option>"
msgstr ""

#: glib-genmarshal.xml:95(para) glib-mkenums.xml:129(para)
#: gobject-query.xml:102(para)
msgid "Print version and exit."
msgstr ""

#: glib-mkenums.xml:10(refname) glib-mkenums.xml:16(command)
#: glib-mkenums.xml:4(refentrytitle)
msgid "glib-mkenums"
msgstr ""

#: glib-mkenums.xml:104(option)
msgid "--template"
msgstr ""

#: glib-mkenums.xml:104(replaceable)
msgid "file"
msgstr ""

#: glib-mkenums.xml:105(para)
msgid ""
"Read templates from the given file. The templates are enclosed in specially-"
"formatted C comments <placeholder-1/> where section may be <literal>file-"
"header</literal>, <literal>file-production</literal>, <literal>file-tail</"
"literal>, <literal>enumeration-production</literal>, <literal>value-header</"
"literal>, <literal>value-production</literal>, <literal>value-tail</literal> "
"or <literal>comment</literal>."
msgstr ""

#: glib-mkenums.xml:108(programlisting)
#, no-wrap
msgid ""
"\n"
"/*** BEGIN section ***/\n"
"/*** END section ***/\n"
msgstr ""

#: glib-mkenums.xml:11(refpurpose)
msgid "C language enum description generation utility"
msgstr ""

#: glib-mkenums.xml:121(option)
msgid "--help"
msgstr ""

#: glib-mkenums.xml:128(option)
msgid "--version"
msgstr ""

#: glib-mkenums.xml:137(title)
msgid "Production text substitutions"
msgstr ""

#: glib-mkenums.xml:138(para)
msgid ""
"Certain keywords enclosed in @ characters will be substituted in the emitted "
"text. For the substitution examples of the keywords below, the following "
"example enum definition is assumed: <placeholder-1/><placeholder-2/>"
msgstr ""

#: glib-mkenums.xml:142(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef enum\n"
"{\n"
"  PREFIX_THE_XVALUE    = 1 &lt;&lt; 3,\n"
"  PREFIX_ANOTHER_VALUE = 1 &lt;&lt; 4\n"
"} PrefixTheXEnum;\n"
msgstr ""

#: glib-mkenums.xml:151(term)
msgid "@EnumName@"
msgstr ""

#: glib-mkenums.xml:152(para)
msgid ""
"The name of the enum currently being processed, enum names are assumed to be "
"properly namespaced and to use mixed capitalization to separate words (e.g. "
"PrefixTheXEnum)."
msgstr ""

#: glib-mkenums.xml:160(term)
msgid "@enum_name@"
msgstr ""

#: glib-mkenums.xml:161(para)
msgid ""
"The enum name with words lowercase and word-separated by underscores (e.g. "
"prefix_the_xenum)."
msgstr ""

#: glib-mkenums.xml:168(term)
msgid "@ENUMNAME@"
msgstr ""

#: glib-mkenums.xml:169(para)
msgid ""
"The enum name with words uppercase and word-separated by underscores (e.g. "
"PREFIX_THE_XENUM)."
msgstr ""

#: glib-mkenums.xml:176(term)
msgid "@ENUMSHORT@"
msgstr ""

#: glib-mkenums.xml:177(para)
msgid ""
"The enum name with words uppercase and word-separated by underscores, prefix "
"stripped (e.g. THE_XENUM)."
msgstr ""

#: glib-mkenums.xml:184(term)
msgid "@VALUENAME@"
msgstr ""

#: glib-mkenums.xml:185(para)
msgid ""
"The enum value name currently being processed with words uppercase and word-"
"separated by underscores, this is the assumed literal notation of enum "
"values in the C sources (e.g. PREFIX_THE_XVALUE)."
msgstr ""

#: glib-mkenums.xml:194(term)
msgid "@valuenick@"
msgstr ""

#: glib-mkenums.xml:195(para)
msgid ""
"A nick name for the enum value currently being processed, this is usually "
"generated by stripping common prefix words of all the enum values of the "
"current enum, the words are lowercase and underscores are substituted by a "
"minus (e.g. the-xvalue)."
msgstr ""

#: glib-mkenums.xml:204(term)
msgid "@valuenum@"
msgstr ""

#: glib-mkenums.xml:205(para)
msgid ""
"The integer value for the enum value currently being processed. This is "
"calculated by using <command>perl</command> to attempt to evaluate the "
"expression as it appears in the C source code. If evaluation fails then "
"<command>glib-mkenums</command> will exit with an error status, but this "
"only happens if <literal>@valuenum@</literal> appears in your value "
"production template. (Since: 2.26)"
msgstr ""

#: glib-mkenums.xml:216(term)
msgid "@type@"
msgstr ""

#: glib-mkenums.xml:217(para)
msgid ""
"This is substituted either by \"enum\" or \"flags\", depending on whether "
"the enum value definitions contained bit-shift operators or not (e.g. flags)."
msgstr ""

#: glib-mkenums.xml:224(term)
msgid "@Type@"
msgstr ""

#: glib-mkenums.xml:225(para)
msgid ""
"The same as <literal>@type@</literal> with the first letter capitalized (e."
"g. Flags)."
msgstr ""

#: glib-mkenums.xml:23(para)
msgid ""
"<command>glib-mkenums</command> is a small perl-script utility that parses C "
"code to extract enum definitions and produces enum descriptions based on "
"text templates specified by the user. Most frequently this script is used to "
"produce C code that contains enum values as strings so programs can provide "
"value name strings for introspection."
msgstr ""

#: glib-mkenums.xml:231(term)
msgid "@TYPE@"
msgstr ""

#: glib-mkenums.xml:232(para)
msgid ""
"The same as <literal>@type@</literal> with all letters uppercased (e.g. "
"FLAGS)."
msgstr ""

#: glib-mkenums.xml:238(term)
msgid "@filename@"
msgstr ""

#: glib-mkenums.xml:239(para)
msgid "The name of the input file currently being processed (e.g. foo.h)."
msgstr ""

#: glib-mkenums.xml:245(term)
msgid "@basename@"
msgstr ""

#: glib-mkenums.xml:246(para)
msgid ""
"The base name of the input file currently being processed (e.g. foo.h). "
"(Since: 2.22)"
msgstr ""

#: glib-mkenums.xml:253(title)
msgid "Trigraph extensions"
msgstr ""

#: glib-mkenums.xml:254(para)
msgid ""
"Some C comments are treated specially in the parsed enum definitions, such "
"comments start out with the trigraph sequence <literal>/*&lt;</literal> and "
"end with the trigraph sequence <literal>&gt;*/</literal>. Per enum "
"definition, the options \"skip\" and \"flags\" can be specified, to indicate "
"this enum definition to be skipped, or for it to be treated as a flags "
"definition, or to specify the common prefix to be stripped from all values "
"to generate value nicknames, respectively. The \"lowercase_name\" option can "
"be used to specify the word separation used in the *_get_type() function. "
"For instance, /*&lt; lowercase_name=gnome_vfs_uri_hide_options &gt;*/."
msgstr ""

#: glib-mkenums.xml:265(para)
msgid ""
"Per value definition, the options \"skip\" and \"nick\" are supported. The "
"former causes the value to be skipped, and the latter can be used to specify "
"the otherwise auto-generated nickname. Examples: <placeholder-1/>"
msgstr ""

#: glib-mkenums.xml:270(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef enum /*&lt; skip &gt;*/\n"
"{\n"
"  PREFIX_FOO\n"
"} PrefixThisEnumWillBeSkipped;\n"
"typedef enum /*&lt; flags,prefix=PREFIX &gt;*/\n"
"{\n"
"  PREFIX_THE_ZEROTH_VALUE,\t/*&lt; skip &gt;*/\n"
"  PREFIX_THE_FIRST_VALUE,\n"
"  PREFIX_THE_SECOND_VALUE,\n"
"  PREFIX_THE_THIRD_VALUE,\t/*&lt; nick=the-last-value &gt;*/\n"
"} PrefixTheFlagsEnum;\n"
msgstr ""

#: glib-mkenums.xml:32(para)
msgid ""
"<command>glib-mkenums</command> takes a list of valid C code files as input. "
"The options specified control the text that is output, certain substitutions "
"are performed on the text templates for keywords enclosed in @ characters."
msgstr ""

#: glib-mkenums.xml:42(option)
msgid "--fhead"
msgstr ""

#: glib-mkenums.xml:42(replaceable) glib-mkenums.xml:49(replaceable)
#: glib-mkenums.xml:57(replaceable) glib-mkenums.xml:65(replaceable)
#: glib-mkenums.xml:73(replaceable) glib-mkenums.xml:81(replaceable)
#: glib-mkenums.xml:88(replaceable) glib-mkenums.xml:96(replaceable)
msgid "text"
msgstr ""

#: glib-mkenums.xml:43(para)
msgid ""
"Put out <replaceable>text</replaceable> prior to processing input files."
msgstr ""

#: glib-mkenums.xml:49(option)
msgid "--fprod"
msgstr ""

#: glib-mkenums.xml:50(para)
msgid ""
"Put out <replaceable>text</replaceable> everytime a new input file is being "
"processed."
msgstr ""

#: glib-mkenums.xml:57(option)
msgid "--ftail"
msgstr ""

#: glib-mkenums.xml:58(para)
msgid ""
"Put out <replaceable>text</replaceable> after all input files have been "
"processed."
msgstr ""

#: glib-mkenums.xml:65(option)
msgid "--eprod"
msgstr ""

#: glib-mkenums.xml:66(para)
msgid ""
"Put out <replaceable>text</replaceable> everytime an enum is encountered in "
"the input files."
msgstr ""

#: glib-mkenums.xml:73(option)
msgid "--vhead"
msgstr ""

#: glib-mkenums.xml:74(para)
msgid ""
"Put out <replaceable>text</replaceable> before iterating over the set of "
"values of an enum."
msgstr ""

#: glib-mkenums.xml:81(option)
msgid "--vprod"
msgstr ""

#: glib-mkenums.xml:82(para)
msgid "Put out <replaceable>text</replaceable> for every value of an enum."
msgstr ""

#: glib-mkenums.xml:88(option)
msgid "--vtail"
msgstr ""

#: glib-mkenums.xml:89(para)
msgid ""
"Put out <replaceable>text</replaceable> after iterating over all values of "
"an enum."
msgstr ""

#: glib-mkenums.xml:96(option)
msgid "--comments"
msgstr ""

#: glib-mkenums.xml:97(para)
msgid ""
"Template for auto-generated comments, the default (for C code generations) "
"is <literal>\"/* @comment@ */\"</literal>."
msgstr ""

#: gobject-docs.sgml:10(title)
msgid "GObject Reference Manual"
msgstr "GObject 参考手册"

#: gobject-docs.sgml:100(title)
msgid "Index"
msgstr "索引"

#: gobject-docs.sgml:104(title)
msgid "Index of deprecated symbols"
msgstr "已过时符号索引"

#: gobject-docs.sgml:108(title)
msgid "Index of new symbols in 2.2"
msgstr "2.2版本中的新符号索引"

#: gobject-docs.sgml:11(releaseinfo)
msgid ""
"for GObject 2.28.5 The latest version of this documentation can be found on-"
"line at <ulink role=\"online-location\" url=\"http://library.gnome.org/devel/"
"gobject/unstable/\">http://library.gnome.org/devel/gobject/unstable/</ulink>."
msgstr ""
"GObject 当前版本为2.28.5, 最新在线版本请浏览这里<ulink role=\"online-location"
"\" url=\"http://library.gnome.org/devel/gobject/unstable/\">http://library."
"gnome.org/devel/gobject/unstable/</ulink>."

#: gobject-docs.sgml:112(title)
msgid "Index of new symbols in 2.4"
msgstr "2.4版本中的新符号索引"

#: gobject-docs.sgml:116(title)
msgid "Index of new symbols in 2.6"
msgstr "2.6版本中的新符号索引"

#: gobject-docs.sgml:120(title)
msgid "Index of new symbols in 2.8"
msgstr "2.8版本中的新符号索引"

#: gobject-docs.sgml:124(title)
msgid "Index of new symbols in 2.10"
msgstr "2.10版本中的新符号索引"

#: gobject-docs.sgml:128(title)
msgid "Index of new symbols in 2.12"
msgstr "2.12版本中的新符号索引"

#: gobject-docs.sgml:132(title)
msgid "Index of new symbols in 2.14"
msgstr "2.14版本中的新符号索引"

#: gobject-docs.sgml:136(title)
msgid "Index of new symbols in 2.18"
msgstr "2.18版本中的新符号索引"

#: gobject-docs.sgml:140(title)
msgid "Index of new symbols in 2.22"
msgstr "2.22版本中的新符号索引"

#: gobject-docs.sgml:144(title)
msgid "Index of new symbols in 2.24"
msgstr "2.24版本中的新符号索引"

#: gobject-docs.sgml:148(title)
msgid "Index of new symbols in 2.26"
msgstr "2.26版本中的新符号索引"

#: gobject-docs.sgml:152(title)
msgid "Index of new symbols in 2.28"
msgstr "2.28版本中的新符号索引"

#: gobject-docs.sgml:19(title)
msgid "Introduction"
msgstr "前言"

#: gobject-docs.sgml:20(para)
msgid ""
"Most modern programming languages come with their own native object systems "
"and additional fundamental algorithmic language constructs. Just as GLib "
"serves as an implementation of such fundamental types and algorithms (linked "
"lists, hash tables and so forth), the GLib Object System provides the "
"required implementations of a flexible extensible and intentionally easy to "
"map (into other languages) object-oriented framework for C. The substantial "
"elements that are provided can be summarized as: <placeholder-1/>"
msgstr ""
"大多数现代的计算机语言都带有自己的类型和对象系统，并附带算法结构。正如GLib提"
"供的基本类型和算法结构（如链表、哈希表等）一样，GObject的对象系统提供了一种灵"
"活的、可扩展的、并容易映射（到其它语言）的面向对象的C语言框架。它的实质可以概"
"括为： <placeholder-1/>"

#: gobject-docs.sgml:30(para)
msgid ""
"A generic type system to register arbitrary single-inherited flat and deep "
"derived types as well as interfaces for structured types. It takes care of "
"creation, initialization and memory management of the assorted object and "
"class structures, maintains parent/child relationships and deals with "
"dynamic implementations of such types. That is, their type specific "
"implementations are relocatable/unloadable during runtime."
msgstr ""
"一个通用类型系统，用来注册任意的、轻便的、单根继承的、并能推导出任意深度的结"
"构类型的界面，它照顾组合对象的定制、初始化和内存管理，类结构，保持对象的父子"
"关系，处理这些类型的动态实现。也就是说，这些类型的实现是在运行时重置和卸载"
"的。"

#: gobject-docs.sgml:40(para)
msgid ""
"A collection of fundamental type implementations, such as integers, doubles, "
"enums and structured types, to name a few."
msgstr "一个基本类型的实现集，如整型，枚举型和结构型等。"

#: gobject-docs.sgml:44(para)
msgid ""
"A sample fundamental type implementation to base object hierarchies upon - "
"the GObject fundamental type."
msgstr "一个基本对象体系之上的基本对象类型的实现的例子－GObject 基本类型。"

#: gobject-docs.sgml:48(para)
msgid ""
"A signal system that allows very flexible user customization of virtual/"
"overridable object methods and can serve as a powerful notification "
"mechanism."
msgstr ""
"一个信号系统，允许用户非常灵活的自定义虚的或重载对象的方法，并且能充当非常有"
"效力的通知机制。"

#: gobject-docs.sgml:53(para)
msgid ""
"An extensible parameter/value system, supporting all the provided "
"fundamental types that can be used to generically handle object properties "
"or otherwise parameterized types."
msgstr ""
"一个可扩展的参数/变量体系，支持所有的能被用作处理对象属性或其它参数化类型的基"
"本的类型。"

#: gobject-docs.sgml:63(title)
msgid "Concepts"
msgstr "概念"

#: gobject-docs.sgml:71(title)
msgid "API Reference"
msgstr "API 参考"

#: gobject-docs.sgml:89(title)
msgid "Tools Reference"
msgstr "工具参考"

#: gobject-query.xml:10(refname) gobject-query.xml:16(command)
#: gobject-query.xml:21(command) gobject-query.xml:4(refentrytitle)
msgid "gobject-query"
msgstr ""

#: gobject-query.xml:11(refpurpose)
msgid "display a tree of types"
msgstr ""

#: gobject-query.xml:17(arg) gobject-query.xml:44(option)
msgid "froots"
msgstr ""

#: gobject-query.xml:22(arg) gobject-query.xml:51(option)
msgid "tree"
msgstr ""

#: gobject-query.xml:28(para)
msgid ""
"<command>gobject-query</command> is a small utility that draws a tree of "
"types."
msgstr ""

#: gobject-query.xml:35(para)
msgid ""
"<command>gobject-query</command> takes a mandatory argument that specifies "
"whether it should iterate over the fundamental types or print a type tree."
msgstr ""

#: gobject-query.xml:45(para)
msgid "iterate over fundamental roots"
msgstr ""

#: gobject-query.xml:52(para)
msgid "print type tree"
msgstr ""

#: gobject-query.xml:58(option)
msgid "-r"
msgstr ""

#: gobject-query.xml:58(replaceable)
msgid "type"
msgstr ""

#: gobject-query.xml:59(para)
msgid "specify the root type"
msgstr ""

#: gobject-query.xml:65(option)
msgid "-n"
msgstr ""

#: gobject-query.xml:66(para)
msgid "don't descend type tree"
msgstr ""

#: gobject-query.xml:72(option)
msgid "-b"
msgstr ""

#: gobject-query.xml:72(replaceable) gobject-query.xml:79(replaceable)
msgid "string"
msgstr ""

#: gobject-query.xml:73(para)
msgid "specify indent string"
msgstr ""

#: gobject-query.xml:79(option)
msgid "-i"
msgstr ""

#: gobject-query.xml:80(para)
msgid "specify incremental indent string"
msgstr ""

#: gobject-query.xml:87(option)
msgid "-s"
msgstr ""

#: gobject-query.xml:87(replaceable)
msgid "number"
msgstr ""

#: gobject-query.xml:88(para)
msgid "specify line spacing"
msgstr ""

#: tut_gobject.xml:124(programlisting)
#, no-wrap
msgid ""
"\n"
"MamanBar *bar = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
msgstr ""

#: tut_gobject.xml:138(para)
msgid ""
"Once <function><link linkend=\"g-object-new\">g_object_new</link></function> "
"has obtained a reference to an initialized class structure, it invokes its "
"constructor method to create an instance of the new object. Since it has "
"just been overridden by <function>maman_bar_class_init</function> to "
"<function>maman_bar_constructor</function>, the latter is called and, "
"because it was implemented correctly, it chains up to its parent's "
"constructor. In order to find the parent class and chain up to the parent "
"class constructor, we can use the <literal>maman_bar_parent_class</literal> "
"pointer that has been set up for us by the <literal>G_DEFINE_TYPE</literal> "
"macro."
msgstr ""
"一旦<function><link linkend=\"g-object-new\">g_object_new</link></function>得"
"到一个已被初始化的类结构的引用，它就调用它的构造方法来创建一个新对象的实例。"
"因为它刚刚被<function>maman_bar_class_init</function>重载为"
"<function>maman_bar_constructor</function>，因此后者将会被调用，并且如果它的"
"实现是正确的，它会连接到父类的构造器。为了找到父类并链接到父类的构造器，我们"
"可以使用<literal>maman_bar_parent_class</literal>指针，它是由"
"<literal>G_DEFINE_TYPE</literal>宏设置的。"

#: tut_gobject.xml:14(para)
msgid ""
"<link linkend=\"GObject\"><type>GObject</type></link> is a fundamental "
"classed instantiable type. It implements: <placeholder-1/> All the GNOME "
"libraries which use the GLib type system (like GTK+ and GStreamer) inherit "
"from <link linkend=\"GObject\"><type>GObject</type></link> which is why it "
"is important to understand the details of how it works."
msgstr ""
"<link linkend=\"GObject\"><type>GObject</type></link>是一个基本的可类化可实例"
"化的类型。它实现了：<placeholder-1/>所有使用GLib类型系统的GNOME库(如GTK+和"
"GStreamer)都由<link linkend=\"GObject\"><type>GObject</type></link>派生，所以"
"了解它如何工作的细节是非常重要的。"

#: tut_gobject.xml:150(para)
msgid ""
"Finally, at one point or another, <function>g_object_constructor</function> "
"is invoked by the last constructor in the chain. This function allocates the "
"object's instance' buffer through <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function> which means that the "
"instance_init function is invoked at this point if one was registered. After "
"instance_init returns, the object is fully initialized and should be ready "
"to answer any user-request. When <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function> returns, "
"<function>g_object_constructor</function> sets the construction properties "
"(i.e. the properties which were given to <function><link linkend=\"g-object-"
"new\">g_object_new</link></function>) and returns to the user's constructor "
"which is then allowed to do useful instance initialization..."
msgstr ""
"最后，在某个时刻，派生链上的最后一个构造函数会调用"
"<function>g_object_constructor</function>。这个函数通过<function><link "
"linkend=\"g-type-create-instance\">g_type_create_instance</link></function>分"
"配对象实例的缓冲区，这意味着如果有实例被注册的话，那么此时会调用实例初始化"
"（instance_init）函数。在实例初始化函数返回之后，对象就完全初始化好了，并已准"
"备好应答用户的请求。当<function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function>返回时，"
"<function>g_object_constructor</function>设置构造属性(也就是，提供给"
"<function><link linkend=\"g-object-new\">g_object_new</link></function>的属"
"性)，并返回到用户的构造器，用户构造器可用于完成一些有用的实例初始化……"

#: tut_gobject.xml:162(para)
msgid ""
"The process described above might seem a bit complicated, but it can be "
"summarized easily by the table below which lists the functions invoked by "
"<function><link linkend=\"g-object-new\">g_object_new</link></function> and "
"their order of invocation:"
msgstr ""
"上面描述的过程似乎有些复杂，不过它可以用下面的表格来简单总结一下，表格列出了"
"<function><link linkend=\"g-object-new\">g_object_new</link></function>所调用"
"的函数以及它们的调用顺序："

#: tut_gobject.xml:17(para)
msgid "Memory management with reference counting"
msgstr "使用引用计数的内存管理"

#: tut_gobject.xml:171(link) tut_gobject.xml:187(link)
#: tut_gobject.xml:219(link)
msgid "g_object_new"
msgstr ""

#: tut_gobject.xml:179(entry)
msgid "Invocation time"
msgstr "调用时机"

#: tut_gobject.xml:18(para)
msgid "Construction/Destruction of instances"
msgstr "实例的创建和销毁"

#: tut_gobject.xml:180(entry)
msgid "Function Invoked"
msgstr "调用函数"

#: tut_gobject.xml:181(entry)
msgid "Function's parameters"
msgstr "函数的参数"

#: tut_gobject.xml:182(entry)
msgid "Remark"
msgstr "备注"

#: tut_gobject.xml:187(entry)
msgid "First call to <function><placeholder-1/></function> for target type"
msgstr "目标类型首次调用<function><placeholder-1/></function>时"

#: tut_gobject.xml:188(entry)
msgid "target type's base_init function"
msgstr "目标类型的基类初始化函数"

#: tut_gobject.xml:189(entry)
msgid ""
"On the inheritance tree of classes from fundamental type to target type. "
"base_init is invoked once for each class structure."
msgstr ""
"类的继承树上的类型，从基本类型到目标类型，每个类结构都会调用一次基类初始化"
"（base_init）函数。"

#: tut_gobject.xml:19(para)
msgid "Generic per-object properties with set/get function pairs"
msgstr "使用set/get函数对进行的一般性对象属性操作。"

#: tut_gobject.xml:191(entry)
msgid ""
"I have no real idea on how this can be used. If you have a good real-life "
"example of how a class' base_init can be used, please, let me know."
msgstr ""
"我不知道这个特性该怎样被使用。如果你有好的现实生活的例子能用到类的基类初始化"
"的话，请告诉我。"

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:198(entry)
msgid "target type's class_init function"
msgstr "目标类型的类初始化（class_init）函数"

#: tut_gobject.xml:199(entry)
msgid "On target type's class structure"
msgstr "目标类型的类结构"

#: tut_gobject.xml:20(para)
msgid "Easy use of signals"
msgstr "简单易用的信号机制。"

#: tut_gobject.xml:200(entry)
msgid ""
"Here, you should make sure to initialize or override class methods (that is, "
"assign to each class' method its function pointer) and create the signals "
"and the properties associated to your object."
msgstr ""
"这里，你应该确保初始化或重载类的方法(也就是给每一个类方法指派一个函数指针)，"
"并为你的对象创建相关的信号和属性。"

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:208(entry)
msgid "interface' base_init function"
msgstr "接口的基类初始化（base_init）函数"

#: tut_gobject.xml:209(entry) tut_gobject.xml:215(entry)
msgid "On interface' vtable"
msgstr "接口的虚函数表"

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:214(entry)
msgid "interface' interface_init function"
msgstr "接口的接口初始化（interface_init）函数"

#: tut_gobject.xml:219(entry)
msgid "Each call to <function><placeholder-1/></function> for target type"
msgstr "目标类型每次调用<function><placeholder-1/></function>时"

#: tut_gobject.xml:220(entry)
msgid "target type's class constructor method: GObjectClass-&gt;constructor"
msgstr "目标类型的类构造方法：GObjectClass-&gt;constructor"

#: tut_gobject.xml:221(entry)
msgid "On object's instance"
msgstr "对象的实例"

#: tut_gobject.xml:222(entry)
msgid ""
"If you need to complete the object initialization after all the construction "
"properties are set, override the constructor method and make sure to chain "
"up to the object's parent class before doing your own initialization. In "
"doubt, do not override the constructor method."
msgstr ""
"如果你需要在所有的构造属性都被设置之后完成对象的初始化，你应该重载构造方法，"
"并确保在执行你自己的初始化过程之前链接到对象的父类上。拿不准的话，就不要重载"
"构造方法了。"

#. entry>Each call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:231(entry)
msgid "type's instance_init function"
msgstr "类型的实例初始化（instance_init）函数"

#: tut_gobject.xml:232(entry)
msgid ""
"On the inheritance tree of classes from fundamental type to target type. the "
"instance_init provided for each type is invoked once for each instance "
"structure."
msgstr ""
"类的继承树上的类型，从基本类型到目标类型，每个实例结构都会调用一次实例初始化"
"（instance_init）函数。"

#: tut_gobject.xml:235(entry)
msgid ""
"Provide an instance_init function to initialize your object before its "
"construction properties are set. This is the preferred way to initialize a "
"GObject instance. This function is equivalent to C++ constructors."
msgstr ""
"在你的对象的构造属性被设置之前，提供一个实例初始化函数来初始化你的对象。这是"
"初始化一个GObject实例的推荐方式。这个函数等效于C++的构造函数。"

#: tut_gobject.xml:246(para)
msgid ""
"Readers should feel concerned about one little twist in the order in which "
"functions are invoked: while, technically, the class' constructor method is "
"called <emphasis>before</emphasis> the GType's instance_init function (since "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> which calls instance_init is called by "
"<function>g_object_constructor</function> which is the top-level class "
"constructor method and to which users are expected to chain to), the user's "
"code which runs in a user-provided constructor will always run "
"<emphasis>after</emphasis> GType's instance_init function since the user-"
"provided constructor <emphasis>must</emphasis> (you've been warned) chain up "
"<emphasis>before</emphasis> doing anything useful."
msgstr ""
"读者可能会对函数调用的顺序感到困惑：类的构造方法在GType的实例初始化函数"
"<emphasis>之前</emphasis>被调用(因为调用实例初始化的<function><link linkend="
"\"g-type-create-instance\">g_type_create_instance</link></function>函数被用户"
"所期待链接的顶层类构造方法<function>g_object_constructor</function>所调用)，"
"用户提供的构造器中执行的用户代码，总是在GType的实例初始化函数<emphasis>之后</"
"emphasis>执行，因此用户提供的构造器<emphasis>必须</emphasis>在做任何有用的事"
"情之前被链接上。(正如你曾经被警告的那样)"

#: tut_gobject.xml:261(title)
msgid "Object memory management"
msgstr "对象的内存管理"

#: tut_gobject.xml:263(para)
msgid ""
"The memory-management API for GObjects is a bit complicated but the idea "
"behind it is pretty simple: the goal is to provide a flexible model based on "
"reference counting which can be integrated in applications which use or "
"require different memory management models (such as garbage collection, "
"aso...). The methods which are used to manipulate this reference count are "
"described below. <placeholder-1/>"
msgstr ""
"GObject内存管理的API有些复杂，但是它背后的主旨是相当简单的：它的目的是提供一"
"个灵活的基于引用计数的、可以集成到使用或需要各种不同的内存管理模型(例如垃圾回"
"收)的应用程序中的模型。下面描述的方法可用于操作引用计数。<placeholder-1/>"

#: tut_gobject.xml:269(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
"  Refcounting\n"
"*/\n"
"gpointer    g_object_ref                      (gpointer        object);\n"
"void        g_object_unref                    (gpointer        object);\n"
"\n"
"/*\n"
" * Weak References\n"
" */\n"
"typedef void (*GWeakNotify) (gpointer  data,\n"
"                             GObject  *where_the_object_was);\n"
"\n"
"void g_object_weak_ref            (GObject     *object,\n"
"                                   GWeakNotify  notify,\n"
"                                   gpointer     data);\n"
"void g_object_weak_unref          (GObject     *object,\n"
"                                   GWeakNotify  notify,\n"
"                                   gpointer     data);\n"
"void g_object_add_weak_pointer    (GObject     *object, \n"
"                                   gpointer    *weak_pointer_location);\n"
"void g_object_remove_weak_pointer (GObject     *object, \n"
"                                   gpointer    *weak_pointer_location);\n"
"/*\n"
" * Cycle handling\n"
" */\n"
"void g_object_run_dispose         (GObject     *object);\n"
msgstr ""

#: tut_gobject.xml:28(title)
msgid "Object instantiation"
msgstr "对象的实例化"

#: tut_gobject.xml:30(para)
msgid ""
"The <function><link linkend=\"g-object-new\">g_object_new</link></function> "
"family of functions can be used to instantiate any GType which inherits from "
"the GObject base type. All these functions make sure the class and instance "
"structures have been correctly initialized by GLib's type system and then "
"invoke at one point or another the constructor class method which is used "
"to: <placeholder-1/> Although one can expect all class and instance members "
"(except the fields pointing to the parents) to be set to zero, some consider "
"it good practice to explicitly set them."
msgstr ""
"<function><link linkend=\"g-object-new\">g_object_new</link></function>系列函"
"数可被用于实例化从GObject基类派生的任意GType。所有这些函数用于确保类和实例结"
"构被Glib类型系统正确的初始化，接着在某个时刻调用构造类方法来：<placeholder-1/"
">尽管你可以期待所有的类和实例成员(除了指向父类的那部分)都会被设置为0，但是好"
"的做法是显式的设置它们。"

#: tut_gobject.xml:300(title)
msgid "Reference count"
msgstr "引用计数"

#: tut_gobject.xml:302(para)
msgid ""
"The functions <function><link linkend=\"g-object-ref\">g_object_ref</link></"
"function>/<function><link linkend=\"g-object-unref\">g_object_unref</link></"
"function> respectively increase and decrease the reference count.These "
"functions are thread-safe as of GLib 2.8. The reference count is, "
"unsurprisingly, initialized to one by <function><link linkend=\"g-object-new"
"\">g_object_new</link></function> which means that the caller is currently "
"the sole owner of the newly-created reference. When the reference count "
"reaches zero, that is, when <function><link linkend=\"g-object-unref"
"\">g_object_unref</link></function> is called by the last client holding a "
"reference to the object, the <emphasis>dispose</emphasis> and the "
"<emphasis>finalize</emphasis> class methods are invoked."
msgstr ""
"<function><link linkend=\"g-object-ref\">g_object_ref</link></function>/"
"<function><link linkend=\"g-object-unref\">g_object_unref</link></function>函"
"数分别用于增加和减少引用计数。在GLib 2.8中，这些函数是线程安全的。"

#: tut_gobject.xml:313(para)
msgid ""
"Finally, after <emphasis>finalize</emphasis> is invoked, <function><link "
"linkend=\"g-type-free-instance\">g_type_free_instance</link></function> is "
"called to free the object instance. Depending on the memory allocation "
"policy decided when the type was registered (through one of the "
"<function>g_type_register_*</function> functions), the object's instance "
"memory will be freed or returned to the object pool for this type. Once the "
"object has been freed, if it was the last instance of the type, the type's "
"class will be destroyed as described in <xref linkend=\"gtype-instantiable-"
"classed\"/> and <xref linkend=\"gtype-non-instantiable-classed\"/>."
msgstr ""

#: tut_gobject.xml:324(para)
msgid ""
"The table below summarizes the destruction process of a GObject: <table id="
"\"gobject-destruction-table\"><placeholder-1/><tgroup cols=\"3\"><colspec "
"colwidth=\"*\" colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum="
"\"2\" align=\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">Last call to <function><link linkend="
"\"g-object-unref\">g_object_unref</link></function> for an instance of "
"target type </entry><entry>target type's dispose class function</"
"entry><entry>GObject instance</entry><entry> When dispose ends, the object "
"should not hold any reference to any other member object. The object is also "
"expected to be able to answer client method invocations (with possibly an "
"error code but no memory violation) until finalize is executed. dispose can "
"be executed more than once. dispose should chain up to its parent "
"implementation just before returning to the caller. </entry></"
"row><row><entry>target type's finalize class function</entry><entry>GObject "
"instance</entry><entry> Finalize is expected to complete the destruction "
"process initiated by dispose. It should complete the object's destruction. "
"finalize will be executed only once. finalize should chain up to its parent "
"implementation just before returning to the caller. The reason why the "
"destruction process is split is two different phases is explained in <xref "
"linkend=\"gobject-memory-cycles\"/>. </entry></row><row><entry morerows="
"\"3\">Last call to <function><link linkend=\"g-object-unref"
"\">g_object_unref</link></function> for the last instance of target type </"
"entry><entry>interface' interface_finalize function</entry><entry>On "
"interface' vtable</entry><entry>Never used in practice. Unlikely you will "
"need it.</entry></row><row><entry>interface' base_finalize function</"
"entry><entry>On interface' vtable</entry><entry>Never used in practice. "
"Unlikely you will need it.</entry></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry><entry>Never used in practice. Unlikely you will need it.</entry></"
"row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. base_init "
"is invoked once for each class structure.</entry><entry>Never used in "
"practice. Unlikely you will need it.</entry></row></tbody></tgroup></table>"
msgstr ""

#: tut_gobject.xml:327(link)
msgid "g_object_unref"
msgstr ""

#: tut_gobject.xml:38(para)
msgid ""
"Allocate and clear memory through <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function>,"
msgstr ""
"通过<function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function>来分配并清理内存，"

#: tut_gobject.xml:41(para)
msgid "Initialize the object's instance with the construction properties."
msgstr "用构造属性来初始化对象实例"

#: tut_gobject.xml:414(title)
msgid "Weak References"
msgstr "弱引用"

#: tut_gobject.xml:416(para)
msgid ""
"Weak References are used to monitor object finalization: <function><link "
"linkend=\"g-object-weak-ref\">g_object_weak_ref</link></function> adds a "
"monitoring callback which does not hold a reference to the object but which "
"is invoked when the object runs its dispose method. As such, each weak ref "
"can be invoked more than once upon object finalization (since dispose can "
"run more than once during object finalization)."
msgstr ""

#: tut_gobject.xml:425(para)
msgid ""
"<function><link linkend=\"g-object-weak-unref\">g_object_weak_unref</link></"
"function> can be used to remove a monitoring callback from the object."
msgstr ""

#: tut_gobject.xml:430(para)
msgid ""
"Weak References are also used to implement <function><link linkend=\"g-"
"object-add-weak-pointer\">g_object_add_weak_pointer</link></function> and "
"<function><link linkend=\"g-object-remove-weak-pointer"
"\">g_object_remove_weak_pointer</link></function>. These functions add a "
"weak reference to the object they are applied to which makes sure to nullify "
"the pointer given by the user when object is finalized."
msgstr ""

#: tut_gobject.xml:440(title)
msgid "Reference counts and cycles"
msgstr "引用计数和周期"

#: tut_gobject.xml:442(para)
msgid ""
"Note: the following section was inspired by James Henstridge. I guess this "
"means that all praise and all curses will be directly forwarded to him."
msgstr ""

#: tut_gobject.xml:447(para)
msgid ""
"GObject's memory management model was designed to be easily integrated in "
"existing code using garbage collection. This is why the destruction process "
"is split in two phases: the first phase, executed in the dispose handler is "
"supposed to release all references to other member objects. The second "
"phase, executed by the finalize handler is supposed to complete the object's "
"destruction process. Object methods should be able to run without program "
"error (that is, without segfault :) in-between the two phases."
msgstr ""

#: tut_gobject.xml:456(para)
msgid ""
"This two-step destruction process is very useful to break reference counting "
"cycles. While the detection of the cycles is up to the external code, once "
"the cycles have been detected, the external code can invoke <function><link "
"linkend=\"g-object-run-dispose\">g_object_run_dispose</link></function> "
"which will indeed break any existing cycles since it will run the dispose "
"handler associated to the object and thus release all references to other "
"objects."
msgstr ""

#: tut_gobject.xml:464(para)
msgid ""
"Attentive readers might now have understood one of the rules about the "
"dispose handler we stated a bit sooner: the dispose handler can be invoked "
"multiple times. Let's say we have a reference count cycle: object A "
"references B which itself references object A. Let's say we have detected "
"the cycle and we want to destroy the two objects. One way to do this would "
"be to invoke <function><link linkend=\"g-object-run-dispose"
"\">g_object_run_dispose</link></function> on one of the objects."
msgstr ""

#: tut_gobject.xml:473(para)
msgid ""
"If object A releases all its references to all objects, this means it "
"releases its reference to object B. If object B was not owned by anyone "
"else, this is its last reference count which means this last unref runs B's "
"dispose handler which, in turn, releases B's reference on object A. If this "
"is A's last reference count, this last unref runs A's dispose handler which "
"is running for the second time before A's finalize handler is invoked !"
msgstr ""

#: tut_gobject.xml:482(para)
msgid ""
"The above example, which might seem a bit contrived can really happen if "
"your GObject's are being handled by language bindings. I would thus suggest "
"the rules stated above for object destruction are closely followed. "
"Otherwise, <emphasis>Bad Bad Things</emphasis> will happen."
msgstr ""

#: tut_gobject.xml:492(title)
msgid "Object properties"
msgstr "对象的属性"

#: tut_gobject.xml:494(para)
msgid ""
"One of GObject's nice features is its generic get/set mechanism for object "
"properties. When an object is instantiated, the object's class_init handler "
"should be used to register the object's properties with <function><link "
"linkend=\"g-object-class-install-property\">g_object_class_install_property</"
"link></function> (implemented in <filename>gobject.c</filename>)."
msgstr ""

#: tut_gobject.xml:50(para)
msgid ""
"Objects which inherit from GObject are allowed to override this constructor "
"class method: they should however chain to their parent constructor method "
"before doing so: <placeholder-1/>"
msgstr ""
"由GObject派生的对象被允许重载它的构造类方法：然而在这样做之前，它们需要连接到"
"它们父类的构造方法上：<placeholder-1/>"

#: tut_gobject.xml:502(para)
msgid ""
"The best way to understand how object properties work is by looking at a "
"real example on how it is used: <placeholder-1/> The client code just above "
"looks simple but a lot of things happen under the hood:"
msgstr ""

#: tut_gobject.xml:505(programlisting)
#, no-wrap
msgid ""
"\n"
"/************************************************/\n"
"/* Implementation                               */\n"
"/************************************************/\n"
"\n"
"enum\n"
"{\n"
"  PROP_0,\n"
"\n"
"  PROP_MAMAN_NAME,\n"
"  PROP_PAPA_NUMBER\n"
"};\n"
"\n"
"static void\n"
"maman_bar_set_property (GObject      *object,\n"
"                        guint         property_id,\n"
"                        const GValue *value,\n"
"                        GParamSpec   *pspec)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (object);\n"
"\n"
"  switch (property_id)\n"
"    {\n"
"    case PROP_MAMAN_NAME:\n"
"      g_free (self-&gt;priv-&gt;name);\n"
"      self-&gt;priv-&gt;name = g_value_dup_string (value);\n"
"      g_print (\"maman: %s\\n\", self-&gt;priv-&gt;name);\n"
"      break;\n"
"\n"
"    case PROP_PAPA_NUMBER:\n"
"      self-&gt;priv-&gt;papa_number = g_value_get_uchar (value);\n"
"      g_print (\"papa: &percnt;u\\n\", self-&gt;priv-&gt;papa_number);\n"
"      break;\n"
"\n"
"    default:\n"
"      /* We don't have any other property... */\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_bar_get_property (GObject    *object,\n"
"                        guint       property_id,\n"
"                        GValue     *value,\n"
"                        GParamSpec *pspec)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (object);\n"
"\n"
"  switch (property_id)\n"
"    {\n"
"    case PROP_MAMAN_NAME:\n"
"      g_value_set_string (value, self-&gt;priv-&gt;name);\n"
"      break;\n"
"\n"
"    case PROP_PAPA_NUMBER:\n"
"      g_value_set_uchar (value, self-&gt;priv-&gt;papa_number);\n"
"      break;\n"
"\n"
"    default:\n"
"      /* We don't have any other property... */\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"  GParamSpec *pspec;\n"
"\n"
"  gobject_class-&gt;set_property = maman_bar_set_property;\n"
"  gobject_class-&gt;get_property = maman_bar_get_property;\n"
"\n"
"  pspec = g_param_spec_string (\"maman-name\",\n"
"                               \"Maman construct prop\",\n"
"                               \"Set maman's name\",\n"
"                               \"no-name-set\" /* default value */,\n"
"                               G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_MAMAN_NAME,\n"
"                                   pspec);\n"
"\n"
"  pspec = g_param_spec_uchar (\"papa-number\",\n"
"                              \"Number of current Papa\",\n"
"                              \"Set/Get papa's number\",\n"
"                              0  /* minimum value */,\n"
"                              10 /* maximum value */,\n"
"                              2  /* default value */,\n"
"                              G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_PAPA_NUMBER,\n"
"                                   pspec);\n"
"}\n"
"\n"
"/************************************************/\n"
"/* Use                                          */\n"
"/************************************************/\n"
"\n"
"GObject *bar;\n"
"GValue val = { 0, };\n"
"\n"
"bar = g_object_new (MAMAN_TYPE_SUBBAR, NULL);\n"
"\n"
"g_value_init (&amp;val, G_TYPE_CHAR);\n"
"g_value_set_char (&amp;val, 11);\n"
"\n"
"g_object_set_property (G_OBJECT (bar), \"papa-number\", &amp;val);\n"
"\n"
"g_value_unset (&amp;val);\n"
msgstr ""

#: tut_gobject.xml:54(programlisting)
#, no-wrap
msgid ""
"\n"
"  GObject *(* constructor) (GType                  gtype,\n"
"                            guint                  n_properties,\n"
"                            GObjectConstructParam *properties);\n"
msgstr ""

#: tut_gobject.xml:6(title)
msgid "The GObject base class"
msgstr "基类：GObject"

#: tut_gobject.xml:61(para)
msgid ""
"The example below shows how <type>MamanBar</type> overrides the parent's "
"constructor: <placeholder-1/> If the user instantiates an object "
"<type>MamanBar</type> with: <placeholder-2/> If this is the first "
"instantiation of such an object, the <function>maman_bar_class_init</"
"function> function will be invoked after any "
"<function>maman_bar_base_class_init</function> function. This will make sure "
"the class structure of this new object is correctly initialized. Here, "
"<function>maman_bar_class_init</function> is expected to override the "
"object's class methods and setup the class' own methods. In the example "
"above, the constructor method is the only overridden method: it is set to "
"<function>maman_bar_constructor</function>."
msgstr ""
"下面的例子展示了<type>MamanBar</type>是如何重载父类的构造器：<placeholder-1/>"
"如果用户用下面的方法实例化一个<type>MamanBar</type>对象：<placeholder-2/>如果"
"这是这个对象的首次实例化，那么<function>maman_bar_class_init</function>函数将"
"会在调用<function>maman_bar_base_class_init</function>后才被调用。这将确保这"
"个新对象的类结构被正确的初始化。这里，<function>maman_bar_class_init</"
"function>需要重载对象的类方法，并设置这个类自己的方法。在上面的例子中，构造方"
"法是唯一被重载的方法：它被设置为<function>maman_bar_constructor</function>。"

#: tut_gobject.xml:620(para)
msgid ""
"<function><link linkend=\"g-object-set-property\">g_object_set_property</"
"link></function> first ensures a property with this name was registered in "
"bar's class_init handler. If so, it calls <function><link linkend=\"object-"
"set-property\">object_set_property</link></function> which first walks the "
"class hierarchy, from bottom, most derived type, to top, fundamental type to "
"find the class which registered that property. It then tries to convert the "
"user-provided GValue into a GValue whose type is that of the associated "
"property."
msgstr ""

#: tut_gobject.xml:629(para)
msgid ""
"If the user provides a signed char GValue, as is shown here, and if the "
"object's property was registered as an unsigned int, <function><link linkend="
"\"g-value-transform\">g_value_transform</link></function> will try to "
"transform the input signed char into an unsigned int. Of course, the success "
"of the transformation depends on the availability of the required transform "
"function. In practice, there will almost always be a transformation "
"<placeholder-1/> which matches and conversion will be carried out if needed."
msgstr ""

#: tut_gobject.xml:63(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_IS_BAR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
"\n"
"typedef struct _MamanBar        MamanBar;\n"
"typedef struct _MamanBarClass   MamanBarClass;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /* instance members */\n"
"};\n"
"\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* class members */\n"
"};\n"
"\n"
"/* will create maman_bar_get_type and set maman_bar_parent_class */\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
"\n"
"static GObject *\n"
"maman_bar_constructor (GType                  gtype,\n"
"                       guint                  n_properties,\n"
"                       GObjectConstructParam *properties)\n"
"{\n"
"  GObject *obj;\n"
"\n"
"  {\n"
"    /* Always chain up to the parent constructor */\n"
"    obj = G_OBJECT_CLASS (maman_bar_parent_class)-&gt;constructor (gtype, n_properties, properties);\n"
"  }\n"
"  \n"
"  /* update the object state depending on constructor properties */\n"
"\n"
"  return obj;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;constructor = maman_bar_constructor;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  /* initialize the object */\n"
"}\n"
"\n"
msgstr ""

#: tut_gobject.xml:636(para)
msgid ""
"Its behaviour might not be what you expect but it is up to you to actually "
"avoid relying on these transformations."
msgstr ""

#: tut_gobject.xml:643(para)
msgid ""
"After transformation, the <link linkend=\"GValue\"><type>GValue</type></"
"link> is validated by <function><link linkend=\"g-param-value-validate"
"\">g_param_value_validate</link></function> which makes sure the user's data "
"stored in the <link linkend=\"GValue\"><type>GValue</type></link> matches "
"the characteristics specified by the property's <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link>. Here, the <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link> we provided in class_init has a validation "
"function which makes sure that the GValue contains a value which respects "
"the minimum and maximum bounds of the <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link>. In the example above, the client's GValue "
"does not respect these constraints (it is set to 11, while the maximum is "
"10). As such, the <function><link linkend=\"g-object-set-property"
"\">g_object_set_property</link></function> function will return with an "
"error."
msgstr ""

#: tut_gobject.xml:656(para)
msgid ""
"If the user's GValue had been set to a valid value, <function><link linkend="
"\"g-object-set-property\">g_object_set_property</link></function> would have "
"proceeded with calling the object's set_property class method. Here, since "
"our implementation of Foo did override this method, the code path would jump "
"to <function>foo_set_property</function> after having retrieved from the "
"<link linkend=\"GParamSpec\"><type>GParamSpec</type></link> the "
"<emphasis>param_id</emphasis><placeholder-1/> which had been stored by "
"<function><link linkend=\"g-object-class-install-property"
"\">g_object_class_install_property</link></function>."
msgstr ""

#: tut_gobject.xml:663(para)
msgid ""
"It should be noted that the param_id used here need only to uniquely "
"identify each <link linkend=\"GParamSpec\"><type>GParamSpec</type></link> "
"within the <link linkend=\"FooClass\"><type>FooClass</type></link> such that "
"the switch used in the set and get methods actually works. Of course, this "
"locally-unique integer is purely an optimization: it would have been "
"possible to use a set of <emphasis>if (strcmp (a, b) == 0) {} else if "
"(strcmp (a, b) == 0) {}</emphasis> statements."
msgstr ""

#: tut_gobject.xml:675(para)
msgid ""
"Once the property has been set by the object's set_property class method, "
"the code path returns to <function><link linkend=\"g-object-set-property"
"\">g_object_set_property</link></function> which calls <function><link "
"linkend=\"g-object-notify-queue-thaw\">g_object_notify_queue_thaw</link></"
"function>. This function makes sure that the \"notify\" signal is emitted on "
"the object's instance with the changed property as parameter unless "
"notifications were frozen by <function><link linkend=\"g-object-freeze-notify"
"\">g_object_freeze_notify</link></function>."
msgstr ""

#: tut_gobject.xml:683(para)
msgid ""
"<function><link linkend=\"g-object-thaw-notify\">g_object_thaw_notify</"
"link></function> can be used to re-enable notification of property "
"modifications through the \"notify\" signal. It is important to remember "
"that even if properties are changed while property change notification is "
"frozen, the \"notify\" signal will be emitted once for each of these changed "
"properties as soon as the property change notification is thawed: no "
"property change is lost for the \"notify\" signal. Signal can only be "
"delayed by the notification freezing mechanism."
msgstr ""

#: tut_gobject.xml:692(para)
msgid ""
"It sounds like a tedious task to set up GValues every time when one wants to "
"modify a property. In practice one will rarely do this. The functions "
"<function><link linkend=\"g-object-set-property\">g_object_set_property</"
"link></function> and <function><link linkend=\"g-object-get-property"
"\">g_object_get_property</link></function> are meant to be used by language "
"bindings. For application there is an easier way and that is described next."
msgstr ""

#: tut_gobject.xml:701(title)
msgid "Accessing multiple properties at once"
msgstr "一次性访问多个属性"

#: tut_gobject.xml:703(para)
msgid ""
"It is interesting to note that the <function><link linkend=\"g-object-set"
"\">g_object_set</link></function> and <function><link linkend=\"g-object-set-"
"valist\">g_object_set_valist</link></function> (vararg version) functions "
"can be used to set multiple properties at once. The client code shown above "
"can then be re-written as: <placeholder-1/> This saves us from managing the "
"GValues that we were needing to handle when using <function><link linkend="
"\"g-object-set-property\">g_object_set_property</link></function>. The code "
"above will trigger one notify signal emission for each property modified."
msgstr ""

#: tut_gobject.xml:707(programlisting)
#, no-wrap
msgid ""
"\n"
"MamanBar *foo;\n"
"foo = /* */;\n"
"g_object_set (G_OBJECT (foo),\n"
"              \"papa-number\", 2, \n"
"              \"maman-name\", \"test\", \n"
"              NULL);\n"
msgstr ""

#: tut_gobject.xml:720(para)
msgid ""
"Of course, the _get versions are also available: <function><link linkend=\"g-"
"object-get\">g_object_get</link></function> and <function><link linkend=\"g-"
"object-get-valist\">g_object_get_valist</link></function> (vararg version) "
"can be used to get numerous properties at once."
msgstr ""

#: tut_gobject.xml:726(para)
msgid ""
"These high level functions have one drawback - they don't provide a return "
"result. One should pay attention to the argument types and ranges when using "
"them. A known source of errors is to e.g. pass a gfloat instead of a gdouble "
"and thus shifting all subsequent parameters by four bytes. Also forgetting "
"the terminating NULL will lead to unexpected behaviour."
msgstr ""

#: tut_gobject.xml:734(para)
msgid ""
"Really attentive readers now understand how <function><link linkend=\"g-"
"object-new\">g_object_new</link></function>, <function><link linkend=\"g-"
"object-newv\">g_object_newv</link></function> and <function><link linkend="
"\"g-object-new-valist\">g_object_new_valist</link></function> work: they "
"parse the user-provided variable number of parameters and invoke "
"<function><link linkend=\"g-object-set\">g_object_set</link></function> on "
"the parameters only after the object has been successfully constructed. Of "
"course, the \"notify\" signal will be emitted for each property set."
msgstr ""

#: tut_gobject.xml:8(para)
msgid ""
"The two previous chapters discussed the details of GLib's Dynamic Type "
"System and its signal control system. The GObject library also contains an "
"implementation for a base fundamental type named <link linkend=\"GObject"
"\"><type>GObject</type></link>."
msgstr ""
"前面两个章节讨论了Glib动态类型系统和它的信号控制系统的细节。GObject库同时也包"
"括了一个名为 <link linkend=\"GObject\"><type>GObject</type></link>的最基本的"
"基类的实现。"

#: tut_gsignal.xml:102(para)
msgid ""
"<function><link linkend=\"g-cclosure-new-swap\">g_cclosure_new_swap</link></"
"function> will create a new closure which can invoke the user-provided "
"callback_func with the user-provided user_data as first parameter (instead "
"of being the last parameter as with <function><link linkend=\"g-cclosure-new"
"\">g_cclosure_new</link></function>). When the closure is finalized (second "
"stage of the destruction process), it will invoke the destroy_data function "
"if the user has supplied one."
msgstr ""

#: tut_gsignal.xml:11(para)
msgid ""
"Closures are central to the concept of asynchronous signal delivery which is "
"widely used throughout GTK+ and GNOME applications. A closure is an "
"abstraction, a generic representation of a callback. It is a small structure "
"which contains three objects: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:112(title)
msgid "Non-C closures (for the fearless)"
msgstr ""

#: tut_gsignal.xml:114(para)
msgid ""
"As was explained above, closures hide the details of callback invocation. In "
"C, callback invocation is just like function invocation: it is a matter of "
"creating the correct stack frame for the called function and executing a "
"<emphasis>call</emphasis> assembly instruction."
msgstr ""

#: tut_gsignal.xml:121(para)
msgid ""
"C closure marshallers transform the array of GValues which represent the "
"parameters to the target function into a C-style function parameter list, "
"invoke the user-supplied C function with this new parameter list, get the "
"return value of the function, transform it into a GValue and return this "
"GValue to the marshaller caller."
msgstr ""

#: tut_gsignal.xml:128(para)
msgid ""
"The following code implements a simple marshaller in C for a C function "
"which takes an integer as first parameter and returns void. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:131(programlisting)
#, no-wrap
msgid ""
"\n"
"g_cclosure_marshal_VOID__INT (GClosure     *closure,\n"
"                              GValue       *return_value,\n"
"                              guint         n_param_values,\n"
"                              const GValue *param_values,\n"
"                              gpointer      invocation_hint,\n"
"                              gpointer      marshal_data)\n"
"{\n"
"  typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,\n"
"                                          gint         arg_1,\n"
"                                          gpointer     data2);\n"
"  register GMarshalFunc_VOID__INT callback;\n"
"  register GCClosure *cc = (GCClosure*) closure;\n"
"  register gpointer data1, data2;\n"
"\n"
"  g_return_if_fail (n_param_values == 2);\n"
"\n"
"  data1 = g_value_peek_pointer (param_values + 0);\n"
"  data2 = closure-&gt;data;\n"
"\n"
"  callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);\n"
"\n"
"  callback (data1,\n"
"            g_marshal_value_peek_int (param_values + 1),\n"
"            data2);\n"
"}\n"
msgstr ""

#: tut_gsignal.xml:160(para)
msgid ""
"Of course, there exist other kinds of marshallers. For example, James "
"Henstridge wrote a generic Python marshaller which is used by all Python "
"closures (a Python closure is used to have Python-based callback be invoked "
"by the closure invocation process). This Python marshaller transforms the "
"input GValue list representing the function parameters into a Python tuple "
"which is the equivalent structure in Python (you can look in "
"<function>pyg_closure_marshal</function> in <filename>pygtype.c</filename> "
"in the <emphasis>pygobject</emphasis> module in the GNOME source code "
"repository)."
msgstr ""

#: tut_gsignal.xml:17(para)
msgid ""
"a function pointer (the callback itself) whose prototype looks like: "
"<placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:174(title)
msgid "Signals"
msgstr ""

#: tut_gsignal.xml:176(para)
msgid ""
"GObject's signals have nothing to do with standard UNIX signals: they "
"connect arbitrary application-specific events with any number of listeners. "
"For example, in GTK+, every user event (keystroke or mouse move) is received "
"from the X server and generates a GTK+ event under the form of a signal "
"emission on a given object instance."
msgstr ""

#: tut_gsignal.xml:18(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:184(para)
msgid ""
"Each signal is registered in the type system together with the type on which "
"it can be emitted: users of the type are said to <emphasis>connect</"
"emphasis> to the signal on a given type instance when they register a "
"closure to be invoked upon the signal emission. Users can also emit the "
"signal by themselves or stop the emission of the signal from within one of "
"the closures connected to the signal."
msgstr ""

#: tut_gsignal.xml:193(para)
msgid ""
"When a signal is emitted on a given type instance, all the closures "
"connected to this signal on this type instance will be invoked. All the "
"closures connected to such a signal represent callbacks whose signature "
"looks like: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:197(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (gpointer instance, ... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:203(title)
msgid "Signal registration"
msgstr ""

#: tut_gsignal.xml:205(para)
msgid ""
"To register a new signal on an existing type, we can use any of "
"<function><link linkend=\"g-signal-newv\">g_signal_newv</link></function>, "
"<function><link linkend=\"g-signal-new-valist\">g_signal_new_valist</link></"
"function> or <function><link linkend=\"g-signal-new\">g_signal_new</link></"
"function> functions: <placeholder-1/> The number of parameters to these "
"functions is a bit intimidating but they are relatively simple: "
"<placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:208(programlisting)
#, no-wrap
msgid ""
"\n"
"guint g_signal_newv (const gchar        *signal_name,\n"
"                     GType               itype,\n"
"                     GSignalFlags        signal_flags,\n"
"                     GClosure           *class_closure,\n"
"                     GSignalAccumulator  accumulator,\n"
"                     gpointer            accu_data,\n"
"                     GSignalCMarshaller  c_marshaller,\n"
"                     GType               return_type,\n"
"                     guint               n_params,\n"
"                     GType              *param_types);\n"
msgstr ""

#: tut_gsignal.xml:22(para)
msgid ""
"the user_data pointer which is passed to the callback upon invocation of the "
"closure"
msgstr ""

#: tut_gsignal.xml:223(para)
msgid ""
"signal_name: is a string which can be used to uniquely identify a given "
"signal."
msgstr ""

#: tut_gsignal.xml:226(para)
msgid "itype: is the instance type on which this signal can be emitted."
msgstr ""

#: tut_gsignal.xml:229(para)
msgid ""
"signal_flags: partly defines the order in which closures which were "
"connected to the signal are invoked."
msgstr ""

#: tut_gsignal.xml:233(para)
msgid ""
"class_closure: this is the default closure for the signal: if it is not NULL "
"upon the signal emission, it will be invoked upon this emission of the "
"signal. The moment where this closure is invoked compared to other closures "
"connected to that signal depends partly on the signal_flags."
msgstr ""

#: tut_gsignal.xml:239(para)
msgid ""
"accumulator: this is a function pointer which is invoked after each closure "
"has been invoked. If it returns FALSE, signal emission is stopped. If it "
"returns TRUE, signal emission proceeds normally. It is also used to compute "
"the return value of the signal based on the return value of all the invoked "
"closures."
msgstr ""

#: tut_gsignal.xml:245(para)
msgid ""
"accumulator_data: this pointer will be passed down to each invocation of the "
"accumulator during emission."
msgstr ""

#: tut_gsignal.xml:249(para)
msgid ""
"c_marshaller: this is the default C marshaller for any closure which is "
"connected to this signal."
msgstr ""

#: tut_gsignal.xml:25(para)
msgid ""
"a function pointer which represents the destructor of the closure: whenever "
"the closure's refcount reaches zero, this function will be called before the "
"closure structure is freed."
msgstr ""

#: tut_gsignal.xml:253(para)
msgid "return_type: this is the type of the return value of the signal."
msgstr ""

#: tut_gsignal.xml:256(para)
msgid "n_params: this is the number of parameters this signal takes."
msgstr ""

#: tut_gsignal.xml:259(para)
msgid ""
"param_types: this is an array of GTypes which indicate the type of each "
"parameter of the signal. The length of this array is indicated by n_params."
msgstr ""

#: tut_gsignal.xml:266(para)
msgid ""
"As you can see from the above definition, a signal is basically a "
"description of the closures which can be connected to this signal and a "
"description of the order in which the closures connected to this signal will "
"be invoked."
msgstr ""

#: tut_gsignal.xml:275(title)
msgid "Signal connection"
msgstr ""

#: tut_gsignal.xml:277(para)
msgid ""
"If you want to connect to a signal with a closure, you have three "
"possibilities: <placeholder-1/> It is also possible to connect a different "
"kind of callback on a given signal: emission hooks are invoked whenever a "
"given signal is emitted whatever the instance on which it is emitted. "
"Emission hooks are used for example to get all mouse_clicked emissions in an "
"application to be able to emit the small mouse click sound. Emission hooks "
"are connected with <function><link linkend=\"g-signal-add-emission-hook"
"\">g_signal_add_emission_hook</link></function> and removed with "
"<function><link linkend=\"g-signal-remove-emission-hook"
"\">g_signal_remove_emission_hook</link></function>."
msgstr ""

#: tut_gsignal.xml:280(para)
msgid ""
"You can register a class closure at signal registration: this is a system-"
"wide operation. i.e.: the class_closure will be invoked during each emission "
"of a given signal on all the instances of the type which supports that "
"signal."
msgstr ""

#: tut_gsignal.xml:285(para)
msgid ""
"You can use <function><link linkend=\"g-signal-override-class-closure"
"\">g_signal_override_class_closure</link></function> which overrides the "
"class_closure of a given type. It is possible to call this function only on "
"a derived type of the type on which the signal was registered. This function "
"is of use only to language bindings."
msgstr ""

#: tut_gsignal.xml:291(para)
msgid ""
"You can register a closure with the <function><link linkend=\"g-signal-"
"connect\">g_signal_connect</link></function> family of functions. This is an "
"instance-specific operation: the closure will be invoked only during "
"emission of a given signal on a given instance."
msgstr ""

#: tut_gsignal.xml:308(title)
msgid "Signal emission"
msgstr ""

#: tut_gsignal.xml:310(para)
msgid ""
"Signal emission is done through the use of the <function><link linkend=\"g-"
"signal-emit\">g_signal_emit</link></function> family of functions. "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:313(programlisting)
#, no-wrap
msgid ""
"\n"
"void g_signal_emitv (const GValue *instance_and_params,\n"
"                     guint         signal_id,\n"
"                     GQuark        detail,\n"
"                     GValue       *return_value);\n"
msgstr ""

#: tut_gsignal.xml:320(para)
msgid ""
"The instance_and_params array of GValues contains the list of input "
"parameters to the signal. The first element of the array is the instance "
"pointer on which to invoke the signal. The following elements of the array "
"contain the list of parameters to the signal."
msgstr ""

#: tut_gsignal.xml:326(para)
msgid "signal_id identifies the signal to invoke."
msgstr ""

#: tut_gsignal.xml:329(para)
msgid ""
"detail identifies the specific detail of the signal to invoke. A detail is a "
"kind of magic token/argument which is passed around during signal emission "
"and which is used by closures connected to the signal to filter out unwanted "
"signal emissions. In most cases, you can safely set this value to zero. See "
"<xref linkend=\"signal-detail\"/> for more details about this parameter."
msgstr ""

#: tut_gsignal.xml:33(para)
msgid ""
"The <link linkend=\"GClosure\"><type>GClosure</type></link> structure "
"represents the common functionality of all closure implementations: there "
"exists a different Closure implementation for each separate runtime which "
"wants to use the GObject type system. <placeholder-1/> The GObject library "
"provides a simple <link linkend=\"GCClosure\"><type>GCClosure</type></link> "
"type which is a specific implementation of closures to be used with C/C++ "
"callbacks."
msgstr ""

#: tut_gsignal.xml:336(para)
msgid ""
"return_value holds the return value of the last closure invoked during "
"emission if no accumulator was specified. If an accumulator was specified "
"during signal creation, this accumulator is used to calculate the "
"return_value as a function of the return values of all the closures invoked "
"during emission. <placeholder-1/> If no closure is invoked during emission, "
"the return_value is nonetheless initialized to zero/null."
msgstr ""

#: tut_gsignal.xml:341(para)
msgid ""
"James (again!!) gives a few non-trivial examples of accumulators: <quote> "
"For instance, you may have an accumulator that ignores NULL returns from "
"closures, and only accumulates the non-NULL ones. Another accumulator may "
"try to return the list of values returned by the closures. </quote>"
msgstr ""

#: tut_gsignal.xml:355(para)
msgid ""
"Internally, the GValue array is passed to the emission function proper, "
"<function>signal_emit_unlocked_R</function> (implemented in "
"<filename>gsignal.c</filename>). Signal emission can be decomposed in 5 "
"steps: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:360(para)
msgid ""
"<emphasis>RUN_FIRST</emphasis>: if the G_SIGNAL_RUN_FIRST flag was used "
"during signal registration and if there exist a class_closure for this "
"signal, the class_closure is invoked. Jump to <emphasis>EMISSION_HOOK</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:365(para)
msgid ""
"<emphasis>EMISSION_HOOK</emphasis>: if any emission hook was added to the "
"signal, they are invoked from first to last added. Accumulate return values "
"and jump to <emphasis>HANDLER_RUN_FIRST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:37(para)
msgid ""
"In practice, closures sit at the boundary of language runtimes: if you are "
"writing Python code and one of your Python callbacks receives a signal from "
"a GTK+ widget, the C code in GTK+ needs to execute your Python code. The "
"closure invoked by the GTK+ object invokes the Python callback: it behaves "
"as a normal C object for GTK+ and as a normal Python object for Python code."
msgstr ""

#: tut_gsignal.xml:370(para)
msgid ""
"<emphasis>HANDLER_RUN_FIRST</emphasis>: if any closure were connected with "
"the <function><link linkend=\"g-signal-connect\">g_signal_connect</link></"
"function> family of functions, and if they are not blocked (with the "
"<function><link linkend=\"g-signal-handler-block\">g_signal_handler_block</"
"link></function> family of functions) they are run here, from first to last "
"connected. Jump to <emphasis>RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:377(para)
msgid ""
"<emphasis>RUN_LAST</emphasis>: if the G_SIGNAL_RUN_LAST flag was set during "
"registration and if a class_closure was set, it is invoked here. Jump to "
"<emphasis>HANDLER_RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:383(para)
msgid ""
"<emphasis>HANDLER_RUN_LAST</emphasis>: if any closure were connected with "
"the <function>g_signal_connect_after</function> family of functions, if they "
"were not invoked during HANDLER_RUN_FIRST and if they are not blocked, they "
"are run here, from first to last connected. Jump to <emphasis>RUN_CLEANUP</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:390(para)
msgid ""
"<emphasis>RUN_CLEANUP</emphasis>: if the G_SIGNAL_RUN_CLEANUP flag was set "
"during registration and if a class_closure was set, it is invoked here. "
"Signal emission is completed here."
msgstr ""

#: tut_gsignal.xml:398(para)
msgid ""
"If, at any point during emission (except in RUN_CLEANUP state), one of the "
"closures or emission hook stops the signal emission with <function><link "
"linkend=\"g-signal-stop\">g_signal_stop</link></function>, emission jumps to "
"CLEANUP state."
msgstr ""

#: tut_gsignal.xml:404(para)
msgid ""
"If, at any point during emission, one of the closures or emission hook emits "
"the same signal on the same instance, emission is restarted from the "
"RUN_FIRST state."
msgstr ""

#: tut_gsignal.xml:410(para)
msgid ""
"The accumulator function is invoked in all states, after invocation of each "
"closure (except in EMISSION_HOOK and CLEANUP). It accumulates the closure "
"return value into the signal return value and returns TRUE or FALSE. If, at "
"any point, it does not return TRUE, emission jumps to CLEANUP state."
msgstr ""

#: tut_gsignal.xml:417(para)
msgid ""
"If no accumulator function was provided, the value returned by the last "
"handler run will be returned by <function><link linkend=\"g-signal-emit"
"\">g_signal_emit</link></function>."
msgstr ""

#: tut_gsignal.xml:426(title)
msgid "The <emphasis>detail</emphasis> argument"
msgstr ""

#: tut_gsignal.xml:428(para)
msgid ""
"All the functions related to signal emission or signal connection have a "
"parameter named the <emphasis>detail</emphasis>. Sometimes, this parameter "
"is hidden by the API but it is always there, under one form or another."
msgstr ""

#: tut_gsignal.xml:433(para)
msgid ""
"Of the three main connection functions, only one has an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></"
"link><placeholder-1/>: <placeholder-2/> The two other functions hide the "
"detail parameter in the signal name identification: <placeholder-3/> Their "
"detailed_signal parameter is a string which identifies the name of the "
"signal to connect to. However, the format of this string is structured to "
"look like <emphasis>signal_name::detail_name</emphasis>. Connecting to the "
"signal named <emphasis>notify::cursor_position</emphasis> will actually "
"connect to the signal named <emphasis>notify</emphasis> with the "
"<emphasis>cursor_position</emphasis> name. Internally, the detail string is "
"transformed to a GQuark if it is present."
msgstr ""

#: tut_gsignal.xml:437(para)
msgid ""
"A GQuark is an integer which uniquely represents a string. It is possible to "
"transform back and forth between the integer and string representations with "
"the functions <function><link linkend=\"g-quark-from-string"
"\">g_quark_from_string</link></function> and <function><link linkend=\"g-"
"quark-to-string\">g_quark_to_string</link></function>."
msgstr ""

#: tut_gsignal.xml:442(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure_by_id          (gpointer          instance,\n"
"                           guint          signal_id,\n"
"                           GQuark          detail,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
msgstr ""

#: tut_gsignal.xml:450(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure          (gpointer          instance,\n"
"                           const gchar       *detailed_signal,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
"gulong     g_signal_connect_data              (gpointer          instance,\n"
"                           const gchar     *detailed_signal,\n"
"                           GCallback      c_handler,\n"
"                           gpointer          data,\n"
"                           GClosureNotify      destroy_data,\n"
"                           GConnectFlags      connect_flags);\n"
msgstr ""

#: tut_gsignal.xml:470(para)
msgid ""
"Of the four main signal emission functions, three have an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></link> again: "
"<placeholder-1/> The fourth function hides it in its signal name parameter: "
"<placeholder-2/> The format of the detailed_signal parameter is exactly the "
"same as the format used by the <function><link linkend=\"g-signal-connect"
"\">g_signal_connect</link></function> functions: <emphasis>signal_name::"
"detail_name</emphasis>."
msgstr ""

#: tut_gsignal.xml:473(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emitv        (const GValue       *instance_and_params,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         GValue             *return_value);\n"
"void                  g_signal_emit_valist  (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         va_list             var_args);\n"
"void                  g_signal_emit         (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:48(para)
msgid ""
"A <link linkend=\"GClosure\"><type>GClosure</type></link> provides simple "
"services: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:488(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emit_by_name (gpointer            instance,\n"
"                         const gchar        *detailed_signal,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:497(para)
msgid ""
"If a detail is provided by the user to the emission function, it is used "
"during emission to match against the closures which also provide a detail. "
"If the closures' detail does not match the detail provided by the user, they "
"will not be invoked (even though they are connected to a signal which is "
"being emitted)."
msgstr ""

#: tut_gsignal.xml:504(para)
msgid ""
"This completely optional filtering mechanism is mainly used as an "
"optimization for signals which are often emitted for many different reasons: "
"the clients can filter out which events they are interested in before the "
"closure's marshalling code runs. For example, this is used extensively by "
"the <emphasis>notify</emphasis> signal of GObject: whenever a property is "
"modified on a GObject, instead of just emitting the <emphasis>notify</"
"emphasis> signal, GObject associates as a detail to this signal emission the "
"name of the property modified. This allows clients who wish to be notified "
"of changes to only one property to filter most events before receiving them."
msgstr ""

#: tut_gsignal.xml:51(para)
msgid ""
"Invocation (<function><link linkend=\"g-closure-invoke\">g_closure_invoke</"
"link></function>): this is what closures were created for: they hide the "
"details of callback invocation from the callback invoker."
msgstr ""

#: tut_gsignal.xml:514(para)
msgid ""
"As a simple rule, users can and should set the detail parameter to zero: "
"this will disable completely this optional filtering."
msgstr ""

#: tut_gsignal.xml:56(para)
msgid ""
"Notification: the closure notifies listeners of certain events such as "
"closure invocation, closure invalidation and closure finalization. Listeners "
"can be registered with <function><link linkend=\"g-closure-add-finalize-"
"notifier\">g_closure_add_finalize_notifier</link></function> (finalization "
"notification), <function><link linkend=\"g-closure-add-invalidate-notifier"
"\">g_closure_add_invalidate_notifier</link></function> (invalidation "
"notification) and <function><link linkend=\"g-closure-add-marshal-guards"
"\">g_closure_add_marshal_guards</link></function> (invocation notification). "
"There exist symmetric deregistration functions for finalization and "
"invalidation events (<function><link linkend=\"g-closure-remove-finalize-"
"notifier\">g_closure_remove_finalize_notifier</link></function> and "
"<function><link linkend=\"g-closure-remove-invalidate-notifier"
"\">g_closure_remove_invalidate_notifier</link></function>) but not for the "
"invocation process. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:6(title)
msgid "The GObject messaging system"
msgstr ""

#: tut_gsignal.xml:67(para)
msgid ""
"Closures are reference counted and notify listeners of their destruction in "
"a two-stage process: the invalidation notifiers are invoked before the "
"finalization notifiers."
msgstr ""

#: tut_gsignal.xml:76(title)
msgid "C Closures"
msgstr ""

#: tut_gsignal.xml:78(para)
msgid ""
"If you are using C or C++ to connect a callback to a given event, you will "
"either use simple <link linkend=\"GCClosure\"><type>GCClosure</type></link>s "
"which have a pretty minimal API or the even simpler <function><link linkend="
"\"g-signal-connect\">g_signal_connect</link></function> functions (which "
"will be presented a bit later :). <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:83(programlisting)
#, no-wrap
msgid ""
"\n"
"GClosure *g_cclosure_new             (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_cclosure_new_swap        (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_signal_type_cclosure_new (GType          itype,\n"
"                                      guint          struct_offset);\n"
msgstr ""

#: tut_gsignal.xml:9(title)
msgid "Closures"
msgstr ""

#: tut_gsignal.xml:95(para)
msgid ""
"<function><link linkend=\"g-cclosure-new\">g_cclosure_new</link></function> "
"will create a new closure which can invoke the user-provided callback_func "
"with the user-provided user_data as last parameter. When the closure is "
"finalized (second stage of the destruction process), it will invoke the "
"destroy_data function if the user has supplied one."
msgstr ""

#: tut_gtype.xml:102(para)
msgid ""
"type characteristic flags: <link linkend=\"GTypeFlags\"><type>GTypeFlags</"
"type></link>."
msgstr ""
"类的字符标志：<link linkend=\"GTypeFlags\"><type>GTypeFlags</type></link>。"

#: tut_gtype.xml:114(title)
msgid "Copy functions"
msgstr "复制函数"

#: tut_gtype.xml:116(para)
msgid ""
"The major common point between <emphasis>all</emphasis> GLib types "
"(fundamental and non-fundamental, classed and non-classed, instantiable and "
"non-instantiable) is that they can all be manipulated through a single API "
"to copy/assign them."
msgstr ""
"所有的 Glib 类型（基本和非基本，类化和非类化， 可实例化和不可实例化）的最大共"
"同点是都可以通过单一的 API 来复制或指定它们。"

#: tut_gtype.xml:12(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeInfo               GTypeInfo;\n"
"struct _GTypeInfo\n"
"{\n"
"  /* interface types, classed types, instantiated types */\n"
"  guint16                class_size;\n"
"  \n"
"  GBaseInitFunc          base_init;\n"
"  GBaseFinalizeFunc      base_finalize;\n"
"  \n"
"  /* classed types, instantiated types */\n"
"  GClassInitFunc         class_init;\n"
"  GClassFinalizeFunc     class_finalize;\n"
"  gconstpointer          class_data;\n"
"  \n"
"  /* instantiated types */\n"
"  guint16                instance_size;\n"
"  guint16                n_preallocs;\n"
"  GInstanceInitFunc      instance_init;\n"
"  \n"
"  /* value handling */\n"
"  const GTypeValueTable *value_table;\n"
"};\n"
"GType g_type_register_static (GType             parent_type,\n"
"                              const gchar      *type_name,\n"
"                              const GTypeInfo  *info,\n"
"                              GTypeFlags        flags);\n"
"GType g_type_register_fundamental (GType                       type_id,\n"
"                                   const gchar                *type_name,\n"
"                                   const GTypeInfo            *info,\n"
"                                   const GTypeFundamentalInfo *finfo,\n"
"                                   GTypeFlags                  flags);\n"
"        "
msgstr ""
"\n"
"typedef struct _GTypeInfo               GTypeInfo;\n"
"struct _GTypeInfo\n"
"{\n"
"  /* interface types, classed types, instantiated types */\n"
"  guint16                class_size;\n"
"  \n"
"  GBaseInitFunc          base_init;\n"
"  GBaseFinalizeFunc      base_finalize;\n"
"  \n"
"  /* classed types, instantiated types */\n"
"  GClassInitFunc         class_init;\n"
"  GClassFinalizeFunc     class_finalize;\n"
"  gconstpointer          class_data;\n"
"  \n"
"  /* instantiated types */\n"
"  guint16                instance_size;\n"
"  guint16                n_preallocs;\n"
"  GInstanceInitFunc      instance_init;\n"
"  \n"
"  /* value handling */\n"
"  const GTypeValueTable *value_table;\n"
"};\n"
"GType g_type_register_static (GType             parent_type,\n"
"                              const gchar      *type_name,\n"
"                              const GTypeInfo  *info,\n"
"                              GTypeFlags        flags);\n"
"GType g_type_register_fundamental (GType                       type_id,\n"
"                                   const gchar                *type_name,\n"
"                                   const GTypeInfo            *info,\n"
"                                   const GTypeFundamentalInfo *finfo,\n"
"                                   GTypeFlags                  flags);\n"
"        "

#: tut_gtype.xml:122(para)
msgid ""
"The <link linkend=\"GValue\"><type>GValue</type></link> structure is used as "
"an abstract container for all of these types. Its simplistic API (defined in "
"<filename>gobject/gvalue.h</filename>) can be used to invoke the value_table "
"functions registered during type registration: for example <function><link "
"linkend=\"g-value-copy\">g_value_copy</link></function> copies the content "
"of a <link linkend=\"GValue\"><type>GValue</type></link> to another <link "
"linkend=\"GValue\"><type>GValue</type></link>. This is similar to a C++ "
"assignment which invokes the C++ copy operator to modify the default bit-by-"
"bit copy semantics of C++/C structures/classes."
msgstr ""
"<link linkend=\"GValue\"><type>GValue</type></link>结构被用作所有类型的抽象的"
"容器， 它的极度简化的 API（定义在 <filename>gobject/gvalue.h</filename>）可以"
"被使用请求 value_table 函数被注册当类型注册中： 举个例子，<function><link "
"linkend=\"g-value-copy\">g_value_copy</link></function> 复制了 <link linkend="
"\"GValue\"><type>GValue</type></link>的内容至另一个<link linkend=\"GValue"
"\"><type>GValue</type></link>。 这与 C++ 指派它的复制操作来修改默认的按位复"
"制 C++/C 结构是类似的。"

#: tut_gtype.xml:132(para)
msgid ""
"The following code shows how you can copy around a 64 bit integer, as well "
"as a <link linkend=\"GObject\"><type>GObject</type></link> instance pointer "
"(sample code for this is located in the source tarball for this document in "
"<filename>sample/gtype/test.c</filename>): <placeholder-1/> The important "
"point about the above code is that the exact semantics of the copy calls is "
"undefined since they depend on the implementation of the copy function. "
"Certain copy functions might decide to allocate a new chunk of memory and "
"then to copy the data from the source to the destination. Others might want "
"to simply increment the reference count of the instance and copy the "
"reference to the new GValue."
msgstr ""
"下面的代码向你展示了你是如何复制一个64位的整型，同样 <link linkend=\"GObject"
"\"><type>GObject</type></link> 的实例指针也是这样（代码在<filename>sample/"
"gtype/test.c</filename>中）： <placeholder-1/> 上面代码的重点是关于复制指令的"
"确切语义，并没有详细的定义复制是如何实现的。 复制函数的实现可能是决定请求一新"
"块的内存，并把数据从源复制到目的。 或者可能是简单的增加实例的引用数和复制引用"
"至新的 GValue。"

#: tut_gtype.xml:136(programlisting)
#, no-wrap
msgid ""
"\n"
"static void test_int (void)\n"
"{\n"
"  GValue a_value = {0, }; \n"
"  GValue b_value = {0, };\n"
"  guint64 a, b;\n"
"\n"
"  a = 0xdeadbeaf;\n"
"\n"
"  g_value_init (&amp;a_value, G_TYPE_UINT64);\n"
"  g_value_set_uint64 (&amp;a_value, a);\n"
"\n"
"  g_value_init (&amp;b_value, G_TYPE_UINT64);\n"
"  g_value_copy (&amp;a_value, &amp;b_value);\n"
"\n"
"  b = g_value_get_uint64 (&amp;b_value);\n"
"\n"
"  if (a == b) {\n"
"    g_print (\"Yay !! 10 lines of code to copy around a uint64.\\n\");\n"
"  } else {\n"
"    g_print (\"Are you sure this is not a Z80 ?\\n\");\n"
"  }\n"
"}\n"
"\n"
"static void test_object (void)\n"
"{\n"
"  GObject *obj;\n"
"  GValue obj_vala = {0, };\n"
"  GValue obj_valb = {0, };\n"
"  obj = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
"\n"
"  g_value_init (&amp;obj_vala, MAMAN_TYPE_BAR);\n"
"  g_value_set_object (&amp;obj_vala, obj);\n"
"\n"
"  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);\n"
"\n"
"  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.\n"
"     This function thus calls g_object_ref.\n"
"     It is interesting to note that the assignment works here because\n"
"     MAMAN_TYPE_BAR is a G_TYPE_OBJECT.\n"
"   */\n"
"  g_value_copy (&amp;obj_vala, &amp;obj_valb);\n"
"\n"
"  g_object_unref (G_OBJECT (obj));\n"
"  g_object_unref (G_OBJECT (obj));\n"
"}\n"
msgstr ""
"\n"
"static void test_int (void)\n"
"{\n"
"  GValue a_value = {0, }; \n"
"  GValue b_value = {0, };\n"
"  guint64 a, b;\n"
"\n"
"  a = 0xdeadbeaf;\n"
"\n"
"  g_value_init (&amp;a_value, G_TYPE_UINT64);\n"
"  g_value_set_uint64 (&amp;a_value, a);\n"
"\n"
"  g_value_init (&amp;b_value, G_TYPE_UINT64);\n"
"  g_value_copy (&amp;a_value, &amp;b_value);\n"
"\n"
"  b = g_value_get_uint64 (&amp;b_value);\n"
"\n"
"  if (a == b) {\n"
"    g_print (\"Yay !! 10 lines of code to copy around a uint64.\\n\");\n"
"  } else {\n"
"    g_print (\"Are you sure this is not a Z80 ?\\n\");\n"
"  }\n"
"}\n"
"\n"
"static void test_object (void)\n"
"{\n"
"  GObject *obj;\n"
"  GValue obj_vala = {0, };\n"
"  GValue obj_valb = {0, };\n"
"  obj = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
"\n"
"  g_value_init (&amp;obj_vala, MAMAN_TYPE_BAR);\n"
"  g_value_set_object (&amp;obj_vala, obj);\n"
"\n"
"  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);\n"
"\n"
"  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.\n"
"     This function thus calls g_object_ref.\n"
"     It is interesting to note that the assignment works here because\n"
"     MAMAN_TYPE_BAR is a G_TYPE_OBJECT.\n"
"   */\n"
"  g_value_copy (&amp;obj_vala, &amp;obj_valb);\n"
"\n"
"  g_object_unref (G_OBJECT (obj));\n"
"  g_object_unref (G_OBJECT (obj));\n"
"}\n"

#: tut_gtype.xml:190(para)
msgid ""
"The value_table used to specify these assignment functions is defined in "
"<filename>gtype.h</filename> and is thoroughly described in the API "
"documentation provided with GObject (for once ;-) which is why we will not "
"detail its exact semantics. <placeholder-1/> Interestingly, it is also very "
"unlikely you will ever need to specify a value_table during type "
"registration because these value_tables are inherited from the parent types "
"for non-fundamental types which means that unless you want to write a "
"fundamental type (not a great idea!), you will not need to provide a new "
"value_table since you will inherit the value_table structure from your "
"parent type."
msgstr ""
"value_table 用于详细说明这些定义在 <filename>gtype.h</filename> 的函数的使用"
"并彻底地描述在由 GObject 提供的API文档中，这是为什么我们不追究细节的原因。 "
"<placeholder-1/> 有趣的是，你同样不需要详细指定一个 value_table 在注册过程"
"中， 因为 value_tables 一般从非基本类型的父类中继承，这意味着除非你想写一个基"
"本类型， 否则你将不需要提供一个新的 value_table 因为它可以从父类继承 "
"value_table。"

#: tut_gtype.xml:195(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeValueTable         GTypeValueTable;\n"
"struct _GTypeValueTable\n"
"{\n"
"  void     (*value_init)         (GValue       *value);\n"
"  void     (*value_free)         (GValue       *value);\n"
"  void     (*value_copy)         (const GValue *src_value,\n"
"                                  GValue       *dest_value);\n"
"  /* varargs functionality (optional) */\n"
"  gpointer (*value_peek_pointer) (const GValue *value);\n"
"  gchar            *collect_format;\n"
"  gchar*   (*collect_value)      (GValue       *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"  gchar            *lcopy_format;\n"
"  gchar*   (*lcopy_value)        (const GValue *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"};\n"
"          "
msgstr ""
"\n"
"typedef struct _GTypeValueTable         GTypeValueTable;\n"
"struct _GTypeValueTable\n"
"{\n"
"  void     (*value_init)         (GValue       *value);\n"
"  void     (*value_free)         (GValue       *value);\n"
"  void     (*value_copy)         (const GValue *src_value,\n"
"                                  GValue       *dest_value);\n"
"  /* varargs functionality (optional) */\n"
"  gpointer (*value_peek_pointer) (const GValue *value);\n"
"  gchar            *collect_format;\n"
"  gchar*   (*collect_value)      (GValue       *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"  gchar            *lcopy_format;\n"
"  gchar*   (*lcopy_value)        (const GValue *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"};\n"
"          "

#: tut_gtype.xml:228(title)
msgid "Conventions"
msgstr "约定"

#: tut_gtype.xml:231(para)
msgid ""
"There are a number of conventions users are expected to follow when creating "
"new types which are to be exported in a header file: <placeholder-1/> The "
"implementation of these macros is pretty straightforward: a number of simple-"
"to-use macros are provided in <filename>gtype.h</filename>. For the example "
"we used above, we would write the following trivial code to declare the "
"macros: <placeholder-2/><placeholder-3/>"
msgstr ""
"当用户在头文件中创建新类型时，有一些规范用户需要注意： <placeholder-1/> 至于"
"这些宏的实现是非常直观的： 一些数量的简单使用的宏由<filename>gtype.h</"
"filename>提供。 针对上面我们兴趣的例子，我们写了下面的代码来声明这些宏： "
"<placeholder-2/><placeholder-3/>"

#: tut_gtype.xml:235(para)
msgid ""
"Use the <function>object_method</function> pattern for function names: to "
"invoke the method named foo on an instance of object type bar, call "
"<function>bar_foo</function>."
msgstr ""
"使用 <function>object_method</function>的形式来定义函数名称： 例如在一个 bar "
"类中定义一个名为 foo 的函数，则用 <function>bar_foo</function> 。"

#: tut_gtype.xml:240(para)
msgid ""
"Use prefixing to avoid namespace conflicts with other projects. If your "
"library (or application) is named <emphasis>Maman</emphasis>, <placeholder-1/"
"> prefix all your function names with <emphasis>maman_</emphasis>. For "
"example: <function>maman_object_method</function>."
msgstr ""
"使用前缀来避免与其他工程的命名空间冲突。 如果你的库（或应用程序）名为 "
"<emphasis>Maman</emphasis>， <placeholder-1/> 那么所有的函数名称前缀为"
"<emphasis>maman_</emphasis>。 举例: <function>maman_object_method</function>."

#: tut_gtype.xml:243(para)
msgid ""
"<emphasis>Maman</emphasis> is the French word for <emphasis>mum</emphasis> "
"or <emphasis>mother</emphasis> - nothing more and nothing less."
msgstr ""
"<emphasis>Maman</emphasis>在法语中是<emphasis>妈妈</emphasis> 或<emphasis>母"
"亲</emphasis>的意思 - 仅此而已。"

#: tut_gtype.xml:252(para)
msgid ""
"Create a macro named <function>PREFIX_TYPE_OBJECT</function> which always "
"returns the GType for the associated object type. For an object of type "
"<emphasis>Bar</emphasis> in a library prefixed by <emphasis>maman</"
"emphasis>, use: <function>MAMAN_TYPE_BAR</function>. It is common although "
"not a convention to implement this macro using either a global static "
"variable or a function named <function>prefix_object_get_type</function>. We "
"will follow the function pattern wherever possible in this document."
msgstr ""
"创建一个宏命为 <function>PREFIX_TYPE_OBJECT</function>用来返回 GType 关联的对"
"象类型。 比如，<emphasis>Bar</emphasis>这个类在一个以 <emphasis>maman</"
"emphasis>前缀的库中，则使用 <function>MAMAN_TYPE_BAR</function>。 另有一个不"
"成文的规定是，定义一个使用全局静态变或一个名为"
"<function>prefix_object_get_type</function> 的函数来实现这个宏。我们将在后面"
"的章节中讨论这个函数。"

#: tut_gtype.xml:260(para)
msgid ""
"Create a macro named <function>PREFIX_OBJECT (obj)</function> which returns "
"a pointer of type <type>PrefixObject</type>. This macro is used to enforce "
"static type safety by doing explicit casts wherever needed. It also enforces "
"dynamic type safety by doing runtime checks. It is possible to disable the "
"dynamic type checks in production builds (see <link linkend=\"glib-building"
"\">building glib</link>). For example, we would create <function>MAMAN_BAR "
"(obj)</function> to keep the previous example."
msgstr ""
"创建一个宏命名为 <function>PREFIX_OBJECT (obj)</function> 来返回一个指向"
"<type>PrefixObject</type> 类型的指针。 这个宏用于必要时安全地强制转换一个静态"
"类型。 运行环境检查时，同样也是安全地执行动态类型。 在编译glib时是可以禁止动"
"态类型检查的（参见：<link linkend=\"glib-building\">编译glib</link>）。 在处"
"理过程中禁用动态类型检查是可行的。 例如，我们可以创建 MAMAN_BAR(obj) 来保持先"
"前的例子。"

#: tut_gtype.xml:268(para)
msgid ""
"If the type is classed, create a macro named <function>PREFIX_OBJECT_CLASS "
"(klass)</function>. This macro is strictly equivalent to the previous "
"casting macro: it does static casting with dynamic type checking of class "
"structures. It is expected to return a pointer to a class structure of type "
"<type>PrefixObjectClass</type>. Again, an example is: "
"<function>MAMAN_BAR_CLASS</function>."
msgstr ""
"如果类型是类化的，那么创建一个命令为 <function>PREFIX_OBJECT_CLASS (klass)</"
"function>的宏。 这个宏与前面那个是非常相似的： 它以类结构的动态类型检查来进行"
"静态转换，并返回一个指向 <type>PrefixObjectClass</type> 这个类型的类结构的指"
"针。 同样，例子为：<function>MAMAN_BAR_CLASS</function>。"

#: tut_gtype.xml:275(para)
msgid ""
"Create a macro named <function>PREFIX_IS_BAR (obj)</function>: this macro is "
"expected to return a <type>gboolean</type> which indicates whether or not "
"the input object instance pointer of type BAR."
msgstr ""
"创建一个宏命名为<function>PREFIX_IS_BAR (obj)</function>： 这个宏的返回值是 "
"<type>gboolean</type> 类型的，用于判断输入的对象实例是否是 BAR类型的。"

#: tut_gtype.xml:279(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_IS_OBJECT_CLASS (klass)</function> which, as above, returns "
"a boolean if the input class pointer is a pointer to a class of type OBJECT."
msgstr ""
"如果类型是类化的，创建一个名为 <function>PREFIX_IS_OBJECT_CLASS (klass)</"
"function> 的宏，与上面的类似，返回输入的类型指针是否是 OBJECT 类型。"

#: tut_gtype.xml:283(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_OBJECT_GET_CLASS (obj)</function> which returns the class "
"pointer associated to an instance of a given type. This macro is used for "
"static and dynamic type safety purposes (just like the previous casting "
"macros)."
msgstr ""
"如果类型是类化的，创建一个名为<function>PREFIX_OBJECT_GET_CLASS (obj)</"
"function>，返回一个实例所属的类的类型指针。 这个宏因为安全的原因，被静态和动"
"态类型所使用，就像上面的转换宏一样。"

#: tut_gtype.xml:293(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
msgstr ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"

#: tut_gtype.xml:301(simpara)
msgid ""
"Stick to the naming <varname>klass</varname> as <varname>class</varname> is "
"a registered c++ keyword."
msgstr ""
"这里使用<varname>klass</varname>这个名字，是因为 <varname>class</varname>已经"
"被注册为 c++ 的关键字了。"

#: tut_gtype.xml:304(para)
msgid ""
"The following code shows how to implement the <function>maman_bar_get_type</"
"function> function: <placeholder-1/>"
msgstr ""
"下面的代码实现了<function>maman_bar_get_type</function>这个函数： "
"<placeholder-1/>"

#: tut_gtype.xml:307(programlisting)
#, no-wrap
msgid ""
"\n"
"GType maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      /* You fill this structure. */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""
"\n"
"GType maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      /* You fill this structure. */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"

#: tut_gtype.xml:324(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_TYPE</function> macro: <placeholder-1/>"
msgstr ""
"如果没有特别需要，你也可以使用<function>G_DEFINE_TYPE</function> 宏： "
"<placeholder-1/>"

#: tut_gtype.xml:327(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT)\n"
msgstr ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT)\n"

#: tut_gtype.xml:335(title)
msgid "Non-instantiable non-classed fundamental types"
msgstr "不可实例化和不可类化的基础类型"

#: tut_gtype.xml:337(para)
msgid ""
"A lot of types are not instantiable by the type system and do not have a "
"class. Most of these types are fundamental trivial types such as "
"<emphasis>gchar</emphasis>, registered in <function>g_value_types_init</"
"function> (in <filename>gvaluetypes.c</filename>)."
msgstr ""
"在类型系统中，许多类型是不可实例化而且没有父类的。 大多数这些类型是最基础的基"
"本类型，如<emphasis>gchar</emphasis>，它由<function>g_value_types_init</"
"function>注册（在<filename>gvaluetypes.c</filename>中）。"

#: tut_gtype.xml:343(para)
msgid ""
"To register such a type in the type system, you just need to fill the <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link> structure with zeros "
"since these types are also most of the time fundamental: <placeholder-1/>"
msgstr ""
"如果想在类型系统中注册这样一个类型，你仅仅需要用 0 来填充<link linkend="
"\"GTypeInfo\"><type>GTypeInfo</type></link>结构。 <placeholder-1/>"

#: tut_gtype.xml:347(programlisting)
#, no-wrap
msgid ""
"\n"
"  GTypeInfo info = {\n"
"    0,                                /* class_size */\n"
"    NULL,                        /* base_init */\n"
"    NULL,                        /* base_destroy */\n"
"    NULL,                        /* class_init */\n"
"    NULL,                        /* class_destroy */\n"
"    NULL,                        /* class_data */\n"
"    0,                                /* instance_size */\n"
"    0,                                /* n_preallocs */\n"
"    NULL,                        /* instance_init */\n"
"    NULL,                        /* value_table */\n"
"  };\n"
"  static const GTypeValueTable value_table = {\n"
"    value_init_long0,                /* value_init */\n"
"    NULL,                        /* value_free */\n"
"    value_copy_long0,                /* value_copy */\n"
"    NULL,                        /* value_peek_pointer */\n"
"    \"i\",                        /* collect_format */\n"
"    value_collect_int,        /* collect_value */\n"
"    \"p\",                        /* lcopy_format */\n"
"    value_lcopy_char,                /* lcopy_value */\n"
"  };\n"
"  info.value_table = &amp;value_table;\n"
"  type = g_type_register_fundamental (G_TYPE_CHAR, \"gchar\", &amp;info, &amp;finfo, 0);\n"
"          "
msgstr ""
"\n"
"  GTypeInfo info = {\n"
"    0,                                /* class_size */\n"
"    NULL,                        /* base_init */\n"
"    NULL,                        /* base_destroy */\n"
"    NULL,                        /* class_init */\n"
"    NULL,                        /* class_destroy */\n"
"    NULL,                        /* class_data */\n"
"    0,                                /* instance_size */\n"
"    0,                                /* n_preallocs */\n"
"    NULL,                        /* instance_init */\n"
"    NULL,                        /* value_table */\n"
"  };\n"
"  static const GTypeValueTable value_table = {\n"
"    value_init_long0,                /* value_init */\n"
"    NULL,                        /* value_free */\n"
"    value_copy_long0,                /* value_copy */\n"
"    NULL,                        /* value_peek_pointer */\n"
"    \"i\",                        /* collect_format */\n"
"    value_collect_int,        /* collect_value */\n"
"    \"p\",                        /* lcopy_format */\n"
"    value_lcopy_char,                /* lcopy_value */\n"
"  };\n"
"  info.value_table = &amp;value_table;\n"
"  type = g_type_register_fundamental (G_TYPE_CHAR, \"gchar\", &amp;info, &amp;finfo, 0);\n"
"          "

#: tut_gtype.xml:376(para)
msgid ""
"Having non-instantiable types might seem a bit useless: what good is a type "
"if you cannot instantiate an instance of that type ? Most of these types are "
"used in conjunction with <link linkend=\"GValue\"><type>GValue</type></"
"link>s: a GValue is initialized with an integer or a string and it is passed "
"around by using the registered type's value_table. <link linkend=\"GValue"
"\"><type>GValue</type></link>s (and by extension these trivial fundamental "
"types) are most useful when used in conjunction with object properties and "
"signals."
msgstr ""
"使用不可实例的类型似乎是无用的： 定义一个不能实例化的类型有什么好处呢？ 大多"
"数这种类型与 <link linkend=\"GValue\"><type>GValue</type></link>用作一块： 一"
"个GValue由一个整型或一个字符串来初始化， 再被传递了一个已注册类型的 "
"value_table 。 <link linkend=\"GValue\"><type>GValue</type></link>（以基本类"
"型延伸）最有用的时候是在与对象的属性和信号用在一块时。"

#: tut_gtype.xml:388(title)
msgid "Instantiable classed types: objects"
msgstr "可实例化的类型：object"

#: tut_gtype.xml:390(para)
msgid ""
"Types which are registered with a class and are declared instantiable are "
"what most closely resembles an <emphasis>object</emphasis>. Although <link "
"linkend=\"GObject\"><type>GObject</type></link>s (detailed in <xref linkend="
"\"chapter-gobject\"/>) are the most well known type of instantiable classed "
"types, other kinds of similar objects used as the base of an inheritance "
"hierarchy have been externally developed and they are all built on the "
"fundamental features described below."
msgstr ""
"一个以类来注册，并声明为可实例化的类型常常称作<emphasis>object</emphasis>。 "
"<link linkend=\"GObject\"><type>GObject</type></link>（详见：<xref linkend="
"\"chapter-gobject\"/> 中）是最有名的一个可实例化的类了， 其他相似的类都继承于"
"这个基本类来进行开发，他们都基于下面所述的基本特征。"

#: tut_gtype.xml:400(para)
msgid ""
"For example, the code below shows how you could register such a fundamental "
"object type in the type system: <placeholder-1/> Upon the first call to "
"<function>maman_bar_get_type</function>, the type named <emphasis>BarType</"
"emphasis> will be registered in the type system as inheriting from the type "
"<emphasis>G_TYPE_OBJECT</emphasis>."
msgstr ""
"下面的例子告诉你怎样才可以在类型系统中注册这样一个基本的类: <placeholder-1/> "
"在调用<function>maman_bar_get_type</function>之前， 名为<emphasis>BarType</"
"emphasis>的继承于<emphasis>G_TYPE_OBJECT</emphasis>的类将在类型系统中被注册。"

#: tut_gtype.xml:403(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct {\n"
"  GObject parent;\n"
"  /* instance members */\n"
"  int field_a;\n"
"} MamanBar;\n"
"\n"
"typedef struct {\n"
"  GObjectClass parent;\n"
"  /* class members */\n"
"  void (*do_action_public_virtual) (MamanBar *self, guint8 i);\n"
"\n"
"  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);\n"
"} MamanBarClass;\n"
"\n"
"#define MAMAN_TYPE_BAR (maman_bar_get_type ())\n"
"\n"
"GType \n"
"maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBarClass),\n"
"      NULL,           /* base_init */\n"
"      NULL,           /* base_finalize */\n"
"      (GClassInitFunc) foo_class_init,\n"
"      NULL,           /* class_finalize */\n"
"      NULL,           /* class_data */\n"
"      sizeof (MamanBar),\n"
"      0,              /* n_preallocs */\n"
"      (GInstanceInitFunc) NULL /* instance_init */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"BarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""
"\n"
"typedef struct {\n"
"  GObject parent;\n"
"  /* instance members */\n"
"  int field_a;\n"
"} MamanBar;\n"
"\n"
"typedef struct {\n"
"  GObjectClass parent;\n"
"  /* class members */\n"
"  void (*do_action_public_virtual) (MamanBar *self, guint8 i);\n"
"\n"
"  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);\n"
"} MamanBarClass;\n"
"\n"
"#define MAMAN_TYPE_BAR (maman_bar_get_type ())\n"
"\n"
"GType \n"
"maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBarClass),\n"
"      NULL,           /* base_init */\n"
"      NULL,           /* base_finalize */\n"
"      (GClassInitFunc) foo_class_init,\n"
"      NULL,           /* class_finalize */\n"
"      NULL,           /* class_data */\n"
"      sizeof (MamanBar),\n"
"      0,              /* n_preallocs */\n"
"      (GInstanceInitFunc) NULL /* instance_init */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"BarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"

#: tut_gtype.xml:448(para)
msgid ""
"Every object must define two structures: its class structure and its "
"instance structure. All class structures must contain as first member a "
"<link linkend=\"GTypeClass\"><type>GTypeClass</type></link> structure. All "
"instance structures must contain as first member a <link linkend="
"\"GTypeInstance\"><type>GTypeInstance</type></link> structure. The "
"declaration of these C types, coming from <filename>gtype.h</filename> is "
"shown below: <placeholder-1/> These constraints allow the type system to "
"make sure that every object instance (identified by a pointer to the "
"object's instance structure) contains in its first bytes a pointer to the "
"object's class structure."
msgstr ""
"每个对象必须定义为两个结构：它的类结构和它的实例结构。 所有的类结构的第一个成"
"员必须是一个<link linkend=\"GTypeClass\"><type>GTypeClass</type></link> 结"
"构。 所有的实例结构的第一个成员必须是 <link linkend=\"GTypeInstance"
"\"><type>GTypeInstance</type></link>结构。 下面显示了这些来自<filename>gtype."
"h</filename> 的 C 类型的声明： <placeholder-1/> 这些约束使得类型系统可以确保"
"每个对象的实例(由指向该对象的实例结构的指针所标识) 的首字节指向该对象的类结"
"构。"

#: tut_gtype.xml:454(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GTypeClass\n"
"{\n"
"  GType g_type;\n"
"};\n"
"struct _GTypeInstance\n"
"{\n"
"  GTypeClass *g_class;\n"
"};\n"
msgstr ""
"\n"
"struct _GTypeClass\n"
"{\n"
"  GType g_type;\n"
"};\n"
"struct _GTypeInstance\n"
"{\n"
"  GTypeClass *g_class;\n"
"};\n"

#: tut_gtype.xml:468(para)
msgid ""
"This relationship is best explained by an example: let's take object B which "
"inherits from object A: <placeholder-1/> The C standard mandates that the "
"first field of a C structure is stored starting in the first byte of the "
"buffer used to hold the structure's fields in memory. This means that the "
"first field of an instance of an object B is A's first field which in turn "
"is GTypeInstance's first field which in turn is g_class, a pointer to B's "
"class structure."
msgstr ""

#: tut_gtype.xml:47(para)
msgid ""
"<function><link linkend=\"g-type-register-static\">g_type_register_static</"
"link></function> and <function><link linkend=\"g-type-register-fundamental"
"\">g_type_register_fundamental</link></function> are the C functions, "
"defined in <filename>gtype.h</filename> and implemented in <filename>gtype."
"c</filename> which you should use to register a new <link linkend=\"GType"
"\"><type>GType</type></link> in the program's type system. It is not likely "
"you will ever need to use <function><link linkend=\"g-type-register-"
"fundamental\">g_type_register_fundamental</link></function> (you have to be "
"Tim Janik to do that) but in case you want to, the last chapter explains how "
"to create new fundamental types. <placeholder-1/>"
msgstr ""
"<function><link linkend=\"g-type-register-static\">g_type_register_static</"
"link></function> 和 <function><link linkend=\"g-type-register-fundamental"
"\">g_type_register_fundamental</link></function> 这两个C函数定义在"
"<filename>gtype.h</filename> 中，并在<filename>gtype.c</filename> 中具体实"
"现。 你可以用来在程序的类型系统中注册一个新的 <link linkend=\"GType"
"\"><type>GType</type></link>。 一般情况下你永远也不需要使用 <function><link "
"linkend=\"g-type-register-fundamental\">g_type_register_fundamental</link></"
"function> （除非你是Tim Janik才会这样做），但是这次你要做，在最后一章会向你解"
"释如何创建一个基本类型。 <placeholder-1/>"

#: tut_gtype.xml:471(programlisting)
#, no-wrap
msgid ""
"\n"
"/* A definitions */\n"
"typedef struct {\n"
"  GTypeInstance parent;\n"
"  int field_a;\n"
"  int field_b;\n"
"} A;\n"
"typedef struct {\n"
"  GTypeClass parent_class;\n"
"  void (*method_a) (void);\n"
"  void (*method_b) (void);\n"
"} AClass;\n"
"\n"
"/* B definitions. */\n"
"typedef struct {\n"
"  A parent;\n"
"  int field_c;\n"
"  int field_d;\n"
"} B;\n"
"typedef struct {\n"
"  AClass parent_class;\n"
"  void (*method_c) (void);\n"
"  void (*method_d) (void);\n"
"} BClass;\n"
msgstr ""
"\n"
"/* A definitions */\n"
"typedef struct {\n"
"  GTypeInstance parent;\n"
"  int field_a;\n"
"  int field_b;\n"
"} A;\n"
"typedef struct {\n"
"  GTypeClass parent_class;\n"
"  void (*method_a) (void);\n"
"  void (*method_b) (void);\n"
"} AClass;\n"
"\n"
"/* B definitions. */\n"
"typedef struct {\n"
"  A parent;\n"
"  int field_c;\n"
"  int field_d;\n"
"} B;\n"
"typedef struct {\n"
"  AClass parent_class;\n"
"  void (*method_c) (void);\n"
"  void (*method_d) (void);\n"
"} BClass;\n"

#: tut_gtype.xml:503(para)
msgid ""
"Thanks to these simple conditions, it is possible to detect the type of "
"every object instance by doing: <placeholder-1/> or, more quickly: "
"<placeholder-2/>"
msgstr ""
"多亏了这些简单的条件，所以按下面的方法来就可能取得每个对象实例的类型： "
"<placeholder-1/> 或者，更快的： <placeholder-2/>"

#: tut_gtype.xml:506(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"b-&gt;parent.parent.g_class-&gt;g_type\n"
msgstr ""
"\n"
"B *b;\n"
"b-&gt;parent.parent.g_class-&gt;g_type\n"

#: tut_gtype.xml:511(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"((GTypeInstance*)b)-&gt;g_class-&gt;g_type\n"
msgstr ""
"\n"
"B *b;\n"
"((GTypeInstance*)b)-&gt;g_class-&gt;g_type\n"

#: tut_gtype.xml:518(title)
msgid "Initialization and Destruction"
msgstr "初始化和销毁"

#: tut_gtype.xml:520(para)
msgid ""
"instantiation of these types can be done with <function><link linkend=\"g-"
"type-create-instance\">g_type_create_instance</link></function>: "
"<placeholder-1/><function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> will look up the type "
"information structure associated to the type requested. Then, the instance "
"size and instantiation policy (if the n_preallocs field is set to a non-zero "
"value, the type system allocates the object's instance structures in chunks "
"rather than mallocing for every instance) declared by the user are used to "
"get a buffer to hold the object's instance structure."
msgstr ""
"实例化这些类型可以用 <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function>来完成： <placeholder-1/"
"><function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> 将查找请求的类型所关联的类型信息结构。 然后由用户声明的实例"
"的大小和实例化策略（如果 n_preallocs 设置为一个非零值， 类型系统将会把对象的"
"实例结构分配在内存块上，而不将依次分配每个实例） 将得到一个缓存来保存对象实例"
"的结构。"

#: tut_gtype.xml:523(programlisting)
#, no-wrap
msgid ""
"\n"
"GTypeInstance* g_type_create_instance (GType          type);\n"
"void           g_type_free_instance   (GTypeInstance *instance);\n"
msgstr ""
"\n"
"GTypeInstance* g_type_create_instance (GType          type);\n"
"void           g_type_free_instance   (GTypeInstance *instance);\n"

#: tut_gtype.xml:535(para)
msgid ""
"If this is the first instance of the object ever created, the type system "
"must create a class structure: it allocates a buffer to hold the object's "
"class structure and initializes it. It first copies the parent's class "
"structure over this structure (if there is no parent, it initializes it to "
"zero). It then invokes the base_class_initialization functions (<link "
"linkend=\"GBaseInitFunc\"><type>GBaseInitFunc</type></link>) from topmost "
"fundamental object to bottom-most most derived object. The object's "
"class_init (<link linkend=\"GClassInitFunc\"><type>GClassInitFunc</type></"
"link>) function is invoked afterwards to complete initialization of the "
"class structure. Finally, the object's interfaces are initialized (we will "
"discuss interface initialization in more detail later)."
msgstr ""
"If this is the first instance of the object ever created, the type system "
"must create 如果实例是这个对象第一次创建的，那么类型系统必须创建一个类结构： "
"它为其分配一个缓冲来保存这个对象的类结构并初始化它。 它先用父类的类结构覆盖"
"（如果没有父类，它将初始化为零）， 然后从最顶层的基本对象至最底层的对象调用 "
"base_class_initialization 函数（<link linkend=\"GBaseInitFunc"
"\"><type>GBaseInitFunc</type></link>）。 对象的类初始化函数（<link linkend="
"\"GClassInitFunc\"><type>GClassInitFunc</type></link>）被调用来完成类结构的初"
"始化。 最终，这个类的接口被初始化了（我们将在后面讨论接口初始化）。"

#: tut_gtype.xml:548(para)
msgid ""
"Once the type system has a pointer to an initialized class structure, it "
"sets the object's instance class pointer to the object's class structure and "
"invokes the object's instance_init (<link linkend=\"GInstanceInitFunc"
"\"><type>GInstanceInitFunc</type></link>)functions, from top-most "
"fundamental type to bottom-most most derived type."
msgstr ""
"一旦类型系统有一个指向初始化的类结构的指针， 它设置对象的实例类指针指向对象的"
"类结构并调用实例的初始化函数（<link linkend=\"GInstanceInitFunc"
"\"><type>GInstanceInitFunc</type></link>）， 同样是从顶到底的顺序。"

#: tut_gtype.xml:555(para)
msgid ""
"Object instance destruction through <function><link linkend=\"g-type-free-"
"instance\">g_type_free_instance</link></function> is very simple: the "
"instance structure is returned to the instance pool if there is one and if "
"this was the last living instance of the object, the class is destroyed."
msgstr ""
"对象的实例的销毁非常简单，通过<function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function>即可： 实例结构被返回到实例池中，如"
"果这是对象的还有一个而且是最后一个存活的实例，那么这个类即被摧毁。"

#: tut_gtype.xml:562(para)
msgid ""
"Class destruction (the concept of destruction is sometimes partly referred "
"to as finalization in GType) is the symmetric process of the initialization: "
"interfaces are destroyed first. Then, the most derived class_finalize (<link "
"linkend=\"ClassFinalizeFunc\"><type>ClassFinalizeFunc</type></link>) "
"function is invoked. The base_class_finalize (<link linkend="
"\"GBaseFinalizeFunc\"><type>GBaseFinalizeFunc</type></link>) functions are "
"Finally invoked from bottom-most most-derived type to top-most fundamental "
"type and the class structure is freed."
msgstr ""
"类的销毁（关于这个销毁的另一概念是 GType 的终结）的过程与初始化的刚好对称： "
"接口先被销毁。 然后，调用类终结函数 class_finalize（<link linkend="
"\"ClassFinalizeFunc\"><type>ClassFinalizeFunc</type></link>）。 最终，将 "
"base_class_finalize（<link linkend=\"GBaseFinalizeFunc"
"\"><type>GBaseFinalizeFunc</type></link>） 从底至顶的调用，直到类结构被销毁。"

#: tut_gtype.xml:573(para)
msgid ""
"As many readers have now understood it, the base initialization/finalization "
"process is very similar to the C++ constructor/destructor paradigm. The "
"practical details are different though and it is important not to get "
"confused by superficial similarities. GTypes have no instance destruction "
"mechanism. It is the user's responsibility to implement correct destruction "
"semantics on top of the existing GType code. (this is what GObject does. See "
"<xref linkend=\"chapter-gobject\"/>) Furthermore, C++ code equivalent to the "
"base_init and class_init callbacks of GType is usually not needed because C+"
"+ cannot really create object types at runtime."
msgstr ""
"很多读者已经明白了，基本的初始化/终结化过程与C++的构造/析构函数非常相似。 实"
"际上细节是非常不同的，千万不要被表现的相似所迷惑。 特别是，大多数用户开始认识"
"到GType中并不存在类似于C++的构造器（这实际上是一个方法列表， 由对象实例来调用"
"所有有继承关系的方法），它必须建立在由GType 提供的特定的设施里。 同样的，"
"GType没有实例销毁机制。 这是用户的职责，在现存的GType代码的顶端来实现正确的销"
"毁（见：<xref linkend=\"chapter-gobject\"/>）。 举个例子，如果从A继承的对象B"
"被实例化了，GType将只调用对象B的instance_init回调函数， 而C++运行环境将先调用"
"对象A的构造器，接着再是对象B。 事实上，C++代码与GType的base_init和class_init"
"回调是等同的， 不过C++常常是不需要这些的，因为它并不能真的在运行时创建类型。"

#: tut_gtype.xml:58(para)
msgid ""
"Please note that there exists another registration function: the "
"<function><link linkend=\"g-type-register-dynamic\">g_type_register_dynamic</"
"link></function>. We will not discuss this function here since its use is "
"very similar to the <function>_static</function> version."
msgstr ""
"请注意，另外一个注册函数是 <function><link linkend=\"g-type-register-dynamic"
"\">g_type_register_dynamic</link></function>。 我们将不讨论这个函数，因为它"
"与 <function>_static</function> 版本非常相似。"

#: tut_gtype.xml:586(para)
msgid ""
"The instantiation/finalization process can be summarized as follows: <table "
"id=\"gtype-init-fini-table\"><placeholder-1/><tgroup cols=\"3\"><colspec "
"colwidth=\"*\" colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum="
"\"2\" align=\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"2\">First call to <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> for target type</"
"entry><entry>type's base_init function</entry><entry>On the inheritance tree "
"of classes from fundamental type to target type. base_init is invoked once "
"for each class structure.</entry></row><row><entry>target type's class_init "
"function</entry><entry>On target type's class structure</entry></"
"row><row><entry>interface initialization, see <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/></entry><entry/></row><row><entry>Each call to "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> for target type</entry><entry>target type's instance_init "
"function</entry><entry>On object's instance</entry></row><row><entry "
"morerows=\"2\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for target type</"
"entry><entry>interface destruction, see <xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/></entry><entry/></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry></row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. "
"base_finalize is invoked once for each class structure.</entry></row></"
"tbody></tgroup></table>"
msgstr ""

#: tut_gtype.xml:589(title)
msgid "GType Instantiation/Finalization"
msgstr ""

#: tut_gtype.xml:6(title)
msgid "The GLib Dynamic Type System"
msgstr "GLib动态类型系统"

#: tut_gtype.xml:652(title)
msgid "Non-instantiable classed types: interfaces"
msgstr "不可实例的类型：接口"

#: tut_gtype.xml:654(para)
msgid ""
"GType's interfaces are very similar to Java's interfaces. They allow to "
"describe a common API that several classes will adhere to. Imagine the play, "
"pause and stop buttons on hi-fi equipment - those can be seen as a playback "
"interface. Once you know what they do, you can control your CD player, MP3 "
"player or anything that uses these symbols. To declare an interface you have "
"to register a non-instantiable classed type which derives from <link linkend="
"\"GTypeInterface\"><type>GTypeInterface</type></link>. The following piece "
"of code declares such an interface. <placeholder-1/> The interface function, "
"<function>maman_ibaz_do_action</function> is implemented in a pretty simple "
"way: <placeholder-2/><function>maman_ibaz_get_type</function> registers a "
"type named <emphasis>MamanIBaz</emphasis> which inherits from "
"G_TYPE_INTERFACE. All interfaces must be children of G_TYPE_INTERFACE in the "
"inheritance tree."
msgstr ""
"GType's interfaces are very similar to Java's interfaces. They allow GType的"
"接口（Interface）与Java的接口非常类似。 它允许描述一个通用的API，使得多个类可"
"以粘合在一起。 想像一下，Hi-Fi音响设备中的暂停和播放按钮──这可以被视做一个回"
"放接口。 如果你知道你要做什么，你可以用来这个接口来控制你的CD机，MP3或其他使"
"用相同符号的东西。 要声明一个接口，你需要注册一个从<link linkend="
"\"GTypeInterface\"><type>GTypeInterface</type></link> 继承的不可实例的类型。 "
"下面的代码声明了这样的一个接口： <placeholder-1/> 这里用非常简单的方法来实现"
"<function>maman_ibaz_do_action</function>这个接口函数： <placeholder-2/"
"><function>maman_ibaz_get_type</function> 注册了一个从G_TYPE_INTERFACE继承的"
"名为<emphasis>MamanIBaz</emphasis>的类型。 在继承树中，所有的接口必须是"
"G_TYPE_INTERFACE的子类。"

#: tut_gtype.xml:663(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_IBAZ                (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"typedef struct _MamanIbaz MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface {\n"
"  GTypeInterface parent;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
msgstr ""
"\n"
"#define MAMAN_TYPE_IBAZ                (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"typedef struct _MamanIbaz MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface {\n"
"  GTypeInterface parent;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"

#: tut_gtype.xml:67(para)
msgid ""
"Fundamental types are top-level types which do not derive from any other "
"type while other non-fundamental types derive from other types. Upon "
"initialization by <function><link linkend=\"g-type-init\">g_type_init</"
"link></function>, the type system not only initializes its internal data "
"structures but it also registers a number of core types: some of these are "
"fundamental types. Others are types derived from these fundamental types."
msgstr ""
"基本类型是不需要从任何其他类型取得的最顶级的类型，相对的， 其他非基本类型是继"
"承于其他类型的。 在由 <function><link linkend=\"g-type-init\">g_type_init</"
"link></function>初始化时，类型系统不仅仅初始化它的内部数据结构， 同时也注册一"
"些核心类型：其中一些是基本类型，其他则是从基本类型继承的。"

#: tut_gtype.xml:684(programlisting)
#, no-wrap
msgid ""
"\n"
"void maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""
"\n"
"void maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"

#: tut_gtype.xml:695(para)
msgid ""
"An interface is defined by only one structure which must contain as first "
"member a <link linkend=\"GTypeInterface\"><type>GTypeInterface</type></link> "
"structure. The interface structure is expected to contain the function "
"pointers of the interface methods. It is good style to define helper "
"functions for each of the interface methods which simply call the interface' "
"method directly: <function>maman_ibaz_do_action</function> is one of these."
msgstr ""
"一个接口只有一个包含<link linkend=\"GTypeInterface\"><type>GTypeInterface</"
"type></link>的结构来定义。 接口的结构应该要包含一个函数指针指向这个接口的方"
"法。 用类似于<function>maman_ibaz_do_action</function>的方法在每个接口方法中"
"定义帮助函数， 可以使得我们直接调用接口方法，这是一个良好的风格。"

#: tut_gtype.xml:704(para)
msgid ""
"Once an interface type is registered, you must register implementations for "
"these interfaces. The function named <function>maman_baz_get_type</function> "
"registers a new GType named MamanBaz which inherits from <link linkend="
"\"GObject\"><type>GObject</type></link> and which implements the interface "
"<type>MamanIBaz</type>. <placeholder-1/>"
msgstr ""
"一旦一个接口的类型被注册后，你必须来实现这个接口。 其中，命名为"
"<function>maman_baz_get_type</function> 注册一个名为<type>MamanIBaz</type>的"
"由<link linkend=\"GObject\"><type>GObject</type></link>继承来的新的GType， 并"
"在接口Interface中实现。 <placeholder-1/>"

#: tut_gtype.xml:709(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_baz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action.\\n\");\n"
"}\n"
"\n"
"\n"
"static void\n"
"baz_interface_init (gpointer         g_iface,\n"
"                    gpointer         iface_data)\n"
"{\n"
"  MamanIbazInterface *iface = (MamanIbazInterface *)g_iface;\n"
"  iface-&gt;do_action = maman_baz_do_action;\n"
"}\n"
"\n"
"GType \n"
"maman_baz_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBazInterface),\n"
"      NULL,   /* base_init */\n"
"      NULL,   /* base_finalize */\n"
"      NULL,   /* class_init */\n"
"      NULL,   /* class_finalize */\n"
"      NULL,   /* class_data */\n"
"      sizeof (MamanBaz),\n"
"      0,      /* n_preallocs */\n"
"      NULL    /* instance_init */\n"
"    };\n"
"    static const GInterfaceInfo ibaz_info = {\n"
"      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */\n"
"      NULL,               /* interface_finalize */\n"
"      NULL          /* interface_data */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBazType\",\n"
"                                   &amp;info, 0);\n"
"    g_type_add_interface_static (type,\n"
"                                 MAMAN_TYPE_IBAZ,\n"
"                                 &amp;ibaz_info);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""
"\n"
"static void maman_baz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action.\\n\");\n"
"}\n"
"\n"
"\n"
"static void\n"
"baz_interface_init (gpointer         g_iface,\n"
"                    gpointer         iface_data)\n"
"{\n"
"  MamanIbazInterface *iface = (MamanIbazInterface *)g_iface;\n"
"  iface-&gt;do_action = maman_baz_do_action;\n"
"}\n"
"\n"
"GType \n"
"maman_baz_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBazInterface),\n"
"      NULL,   /* base_init */\n"
"      NULL,   /* base_finalize */\n"
"      NULL,   /* class_init */\n"
"      NULL,   /* class_finalize */\n"
"      NULL,   /* class_data */\n"
"      sizeof (MamanBaz),\n"
"      0,      /* n_preallocs */\n"
"      NULL    /* instance_init */\n"
"    };\n"
"    static const GInterfaceInfo ibaz_info = {\n"
"      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */\n"
"      NULL,               /* interface_finalize */\n"
"      NULL          /* interface_data */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBazType\",\n"
"                                   &amp;info, 0);\n"
"    g_type_add_interface_static (type,\n"
"                                 MAMAN_TYPE_IBAZ,\n"
"                                 &amp;ibaz_info);\n"
"  }\n"
"  return type;\n"
"}\n"

#: tut_gtype.xml:757(para)
msgid ""
"<function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function> records in the type system "
"that a given type implements also <type>FooInterface</type> "
"(<function>foo_interface_get_type</function> returns the type of "
"<type>FooInterface</type>). The <link linkend=\"GInterfaceInfo"
"\"><type>GInterfaceInfo</type></link> structure holds information about the "
"implementation of the interface: <placeholder-1/>"
msgstr ""
"<function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function> 记录了在类型系统中如 "
"<type>FooInterface</type>来实现的接口（<function>foo_interface_get_type</"
"function>返回<type>FooInterface</type>的类型）， <link linkend="
"\"GInterfaceInfo\"><type>GInterfaceInfo</type></link>保存着关于接口实现的信"
"息： <placeholder-1/>"

#: tut_gtype.xml:76(para)
msgid ""
"Fundamental and non-fundamental types are defined by: <placeholder-1/> "
"Fundamental types are also defined by a set of <link linkend="
"\"GTypeFundamentalFlags\"><type>GTypeFundamentalFlags</type></link> which "
"are stored in a <link linkend=\"GTypeFundamentalInfo"
"\"><type>GTypeFundamentalInfo</type></link>. Non-fundamental types are "
"furthermore defined by the type of their parent which is passed as the "
"parent_type parameter to <function><link linkend=\"g-type-register-static"
"\">g_type_register_static</link></function> and <function><link linkend=\"g-"
"type-register-dynamic\">g_type_register_dynamic</link></function>."
msgstr ""
"不论是基本还是非基本类型，均由下面的定义步骤： <placeholder-1/> 基本类型同样"
"可以由 <link linkend=\"GTypeFundamentalFlags\"><type>GTypeFundamentalFlags</"
"type></link> 来定义，并保存在 <link linkend=\"GTypeFundamentalInfo"
"\"><type>GTypeFundamentalInfo</type></link> 中。非基本类型一般传递一个 "
"parent_type 至<function><link linkend=\"g-type-register-static"
"\">g_type_register_static</link></function> 和 <function><link linkend=\"g-"
"type-register-dynamic\">g_type_register_dynamic</link></function> 中，然后交"
"给父类来定义。"

#: tut_gtype.xml:764(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GInterfaceInfo\n"
"{\n"
"  GInterfaceInitFunc     interface_init;\n"
"  GInterfaceFinalizeFunc interface_finalize;\n"
"  gpointer               interface_data;\n"
"};\n"
msgstr ""
"\n"
"struct _GInterfaceInfo\n"
"{\n"
"  GInterfaceInitFunc     interface_init;\n"
"  GInterfaceFinalizeFunc interface_finalize;\n"
"  gpointer               interface_data;\n"
"};\n"

#: tut_gtype.xml:773(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_INTERFACE</function> macro: <placeholder-1/>"
msgstr ""
"如果没有特殊的需求，你可以直接使用<function>G_DEFINE_INTERFACE</function>这个"
"宏： <placeholder-1/>"

#: tut_gtype.xml:775(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_INTERFACE (MamanBaz, maman_baz, G_TYPE_OBJECT)\n"
msgstr ""
"\n"
"G_DEFINE_INTERFACE (MamanBaz, maman_baz, G_TYPE_OBJECT)\n"

#: tut_gtype.xml:782(title) tut_gtype.xml:839(title)
msgid "Interface Initialization"
msgstr "接口初始化"

#: tut_gtype.xml:784(para)
msgid ""
"When an instantiable classed type which registered an interface "
"implementation is created for the first time, its class structure is "
"initialized following the process described in <xref linkend=\"gtype-"
"instantiable-classed\"/>. After that, the interface implementations "
"associated with the type are initialized."
msgstr ""

#: tut_gtype.xml:79(para)
msgid ""
"class size: the class_size field in <link linkend=\"GTypeInfo"
"\"><type>GTypeInfo</type></link>."
msgstr ""
"类的大小：<link linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>的 "
"class_size。"

#: tut_gtype.xml:793(para)
msgid ""
"First a memory buffer is allocated to hold the interface structure. The "
"parent's interface structure is then copied over to the new interface "
"structure (the parent interface is already initialized at that point). If "
"there is no parent interface, the interface structure is initialized with "
"zeros. The g_type and the g_instance_type fields are then initialized: "
"g_type is set to the type of the most-derived interface and g_instance_type "
"is set to the type of the most derived type which implements this interface."
msgstr ""
"首先为接口结构分配内存缓冲，父接口结构先被复制（父接口先被初始化）。如果没有"
"父接口，接口结构将由0初始化。g_type和 g_instance_type将在其后被初始化：g_type"
"被设置为最先起源的接口，g_instance_type被设置为最先起源的实现这个接口的类。"

#: tut_gtype.xml:8(para)
msgid ""
"A type, as manipulated by the GLib type system, is much more generic than "
"what is usually understood as an Object type. It is best explained by "
"looking at the structure and the functions used to register new types in the "
"type system. <placeholder-1/>"
msgstr ""
"由 Glib 类型系统操作的一个类型，比传统上所讲的 Object 类型更具一般化。 下面查"
"看类型系统中有关类结构和注册新类型的函数，是会对此最好的解释。 "
"<placeholder-1/>"

#: tut_gtype.xml:803(para)
msgid ""
"Finally, the interface' most-derived <function>base_init</function> function "
"and then the implementation's <function>interface_init</function> function "
"are invoked. It is important to understand that if there are multiple "
"implementations of an interface the <function>base_init</function> and "
"<function>interface_init</function> functions will be invoked once for each "
"implementation initialized."
msgstr ""
"最终，接口的最顶层的<function>base_init</function>函数和实现接口的"
"<function>interface_init</function>被调用。了解下面是重要的：如果有一个接口有"
"多个<function>base_init</function>和<function>interface_init</function>的实"
"现，那么每个实现都被调用一次以初始化。"

#: tut_gtype.xml:812(para)
msgid ""
"It is thus common for base_init functions to hold a local static boolean "
"variable which makes sure that the interface type is initialized only once "
"even if there are multiple implementations of the interface: <placeholder-1/>"
msgstr ""
"base_init 函数保持了一个本地静态变量用来确保这个接口类型只被初始化一次而不管"
"它是否被实现了几次：<placeholder-1/>"

#: tut_gtype.xml:816(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean initialized = FALSE;\n"
"\n"
"  if (!initialized) {\n"
"    /* create interface signals here. */\n"
"    initialized = TRUE;\n"
"  }\n"
"}\n"
msgstr ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean initialized = FALSE;\n"
"\n"
"  if (!initialized) {\n"
"    /* create interface signals here. */\n"
"    initialized = TRUE;\n"
"  }\n"
"}\n"

#: tut_gtype.xml:82(para)
msgid ""
"class initialization functions (C++ constructor): the base_init and "
"class_init fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""
"类的初始化函数（C++ 构造函数）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 base_init 和 class_init。"

#: tut_gtype.xml:830(para)
msgid ""
"If you have found the stuff about interface hairy, you are right: it is "
"hairy but there is not much I can do about it. What I can do is summarize "
"what you need to know about interfaces:"
msgstr ""
"如果你发现接口很烦，确实如此。它确实很烦，但是我也没办法啊。我只有把接口的过"
"程归纳一下了！"

#: tut_gtype.xml:836(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-init-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">First call to <function><link "
"linkend=\"g-type-create-instance\">g_type_create_instance</link></function> "
"for type implementing interface </entry><entry>interface' base_init "
"function</entry><entry>On interface' vtable</entry><entry>Register "
"interface' signals here (use a local static boolean variable as described "
"above to make sure not to register them twice.).</entry></"
"row><row><entry>interface' interface_init function</entry><entry>On "
"interface' vtable</entry><entry> Initialize interface' implementation. That "
"is, initialize the interface method pointers in the interface structure to "
"the function's implementation. </entry></row></tbody></tgroup></table> It is "
"highly unlikely (i.e. I do not know of <emphasis>anyone</emphasis> who "
"actually used it) you will ever need other more fancy things such as the "
"ones described in the following section (<xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/>)."
msgstr ""
"上面的处理过程总结如下：<table id=\"ginterface-init-table\"><placeholder-1/"
"><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum=\"1\" align=\"left\"/"
"><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/><colspec colwidth=\"8*"
"\" colnum=\"3\" align=\"left\"/><thead><row><entry>Invocation time</"
"entry><entry>Function Invoked</entry><entry>Function's parameters</"
"entry><entry>Remark</entry></row></thead><tbody><row><entry morerows="
"\"1\">First call to <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> for type implementing interface "
"</entry><entry>interface' base_init function</entry><entry>On interface' "
"vtable</entry><entry>Register interface' signals here (use a local static "
"boolean variable as described above to make sure not to register them "
"twice.).</entry></row><row><entry>interface' interface_init function</"
"entry><entry>On interface' vtable</entry><entry> Initialize interface' "
"implementation. That is, initialize the interface method pointers in the "
"interface structure to the function's implementation. </entry></row></"
"tbody></tgroup></table> It is highly unlikely (i.e. I do not know of "
"<emphasis>anyone</emphasis> who actually used it) you will ever need other "
"more fancy things such as the ones described in the following section (<xref "
"linkend=\"gtype-non-instantiable-classed-dest\"/>).<table id=\"ginterface-"
"init-table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" "
"colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align="
"\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">First call to <function><link "
"linkend=\"g-type-create-instance\">g_type_create_instance</link></function> "
"for type implementing interface </entry><entry>interface' base_init "
"function</entry><entry>On interface' vtable</entry><entry>Register "
"interface' signals here (use a local static boolean variable as described "
"above to make sure not to register them twice.).</entry></"
"row><row><entry>interface' interface_init function</entry><entry>On "
"interface' vtable</entry><entry> Initialize interface' implementation. That "
"is, initialize the interface method pointers in the interface structure to "
"the function's implementation. </entry></row></tbody></tgroup></table> It is "
"highly unlikely (i.e. I do not know of <emphasis>anyone</emphasis> who "
"actually used it) you will ever need other more fancy things such as the "
"ones described in the following section (<xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/>)."

#: tut_gtype.xml:86(para)
msgid ""
"class destruction functions (C++ destructor): the base_finalize and "
"class_finalize fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""
"类的销毁函数（C++析构函数）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 base_finalize 和 class_finalize。"

#: tut_gtype.xml:886(title)
msgid "Interface Destruction"
msgstr "接口的销毁"

#: tut_gtype.xml:888(para)
msgid ""
"When the last instance of an instantiable type which registered an interface "
"implementation is destroyed, the interface's implementations associated to "
"the type are destroyed."
msgstr ""

#: tut_gtype.xml:894(para)
msgid ""
"To destroy an interface implementation, GType first calls the "
"implementation's <function>interface_finalize</function> function and then "
"the interface's most-derived <function>base_finalize</function> function."
msgstr ""

#: tut_gtype.xml:90(para)
msgid ""
"instance size (C++ parameter to new): the instance_size field in <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"实例的大小（C++参数new）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>中 的 instance_size。"

#: tut_gtype.xml:901(para)
msgid ""
"Again, it is important to understand, as in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, that both <function>interface_finalize</"
"function> and <function>base_finalize</function> are invoked exactly once "
"for the destruction of each implementation of an interface. Thus, if you "
"were to use one of these functions, you would need to use a static integer "
"variable which would hold the number of instances of implementations of an "
"interface such that the interface's class is destroyed only once (when the "
"integer variable reaches zero)."
msgstr ""

#: tut_gtype.xml:911(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-fini-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"1\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for type implementing interface </"
"entry><entry>interface' interface_finalize function</entry><entry>On "
"interface' vtable</entry></row><row><entry>interface' base_finalize "
"function</entry><entry>On interface' vtable</entry></row></tbody></tgroup></"
"table>"
msgstr ""

#: tut_gtype.xml:914(title)
msgid "Interface Finalization"
msgstr ""

#: tut_gtype.xml:94(para)
msgid ""
"instantiation policy (C++ type of new operator): the n_preallocs field in "
"<link linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"实例化策略（C++ 类的new operator）：<link linkend=\"GTypeInfo"
"\"><type>GTypeInfo</type></link>的n_preallocs。"

#: tut_gtype.xml:98(para)
msgid ""
"copy functions (C++ copy operators): the value_table field in <link linkend="
"\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"复制函数（C++的复制操作）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 value_table。"

#: tut_howto.xml:1001(title)
msgid "Interface definition prerequisites"
msgstr ""

#: tut_howto.xml:1003(para)
msgid ""
"To specify that an interface requires the presence of other interfaces when "
"implemented, GObject introduces the concept of <emphasis>prerequisites</"
"emphasis>: it is possible to associate a list of prerequisite interfaces to "
"an interface. For example, if object A wishes to implement interface I1, and "
"if interface I1 has a prerequisite on interface I2, A has to implement both "
"I1 and I2."
msgstr ""

#: tut_howto.xml:1012(para)
msgid ""
"The mechanism described above is, in practice, very similar to Java's "
"interface I1 extends interface I2. The example below shows the GObject "
"equivalent: <placeholder-1/> The code shown above adds the MamanIbaz "
"interface to the list of prerequisites of MamanIbar while the code below "
"shows how an implementation can implement both interfaces and register their "
"implementations: <placeholder-2/> It is very important to notice that the "
"order in which interface implementations are added to the main object is not "
"random: <function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function>, which is called by "
"<function>G_IMPLEMENT_INTERFACE</function>, must be invoked first on the "
"interfaces which have no prerequisites and then on the others."
msgstr ""

#: tut_howto.xml:1016(programlisting)
#, no-wrap
msgid ""
"\n"
"  /* inside the GType function of the MamanIbar interface */\n"
"  type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbar\", &amp;info, 0);\n"
"\n"
"  /* Make the MamanIbar interface require MamanIbaz interface. */\n"
"  g_type_interface_add_prerequisite (type, MAMAN_TYPE_IBAZ);\n"
msgstr ""

#: tut_howto.xml:1027(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibar_do_another_action (MamanIbar *ibar)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibar);\n"
"\n"
"  g_print (\"Bar implementation of IBar interface Another Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibar_interface_init (MamanIbarInterface *iface)\n"
"{\n"
"  iface-&gt;do_another_action = maman_ibar_do_another_action;\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_do_action (MamanIbaz *ibaz)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibaz);\n"
"\n"
"  g_print (\"Bar implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = maman_ibaz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;instance_member = 0x666;\n"
"}\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init)\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAR,\n"
"                                                maman_ibar_interface_init));\n"
msgstr ""

#: tut_howto.xml:1086(title)
msgid "Interface Properties"
msgstr ""

#: tut_howto.xml:1088(para)
msgid ""
"Starting from version 2.4 of GLib, GObject interfaces can also have "
"properties. Declaration of the interface properties is similar to declaring "
"the properties of ordinary GObject types as explained in <xref linkend="
"\"gobject-properties\"/>, except that <function><link linkend=\"g-object-"
"interface-install-property\">g_object_interface_install_property</link></"
"function> is used to declare the properties instead of <function><link "
"linkend=\"g-object-class-install-property\">g_object_class_install_property</"
"link></function>."
msgstr ""

#: tut_howto.xml:1097(para)
msgid ""
"To include a property named 'name' of type <type>string</type> in the "
"<type>maman_ibaz</type> interface example code above, we only need to add "
"one <placeholder-1/> line in the <function>maman_ibaz_base_init</"
"function><placeholder-2/> as shown below: <placeholder-3/>"
msgstr ""

#: tut_howto.xml:1102(para)
msgid "That really is one line extended to six for the sake of clarity"
msgstr ""

#: tut_howto.xml:1108(para)
msgid ""
"The <function><link linkend=\"g-object-interface-install-property"
"\">g_object_interface_install_property</link></function> can also be called "
"from <function>class_init</function> but it must not be called after that "
"point."
msgstr ""

#: tut_howto.xml:1115(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      g_object_interface_install_property (g_iface,\n"
"                                           g_param_spec_string (\"name\",\n"
"                                                                \"Name\",\n"
"                                                                \"Name of the MamanIbaz\",\n"
"                                                                \"maman\",\n"
"                                                                G_PARAM_READWRITE));\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
msgstr ""

#: tut_howto.xml:1135(para)
msgid ""
"One point worth noting is that the declared property wasn't assigned an "
"integer ID. The reason being that integer IDs of properties are used only "
"inside the get and set methods and since interfaces do not implement "
"properties, there is no need to assign integer IDs to interface properties."
msgstr ""

#: tut_howto.xml:1143(para)
msgid ""
"An implementation shall declare and define it's properties in the usual way "
"as explained in <xref linkend=\"gobject-properties\"/>, except for one small "
"change: it must declare the properties of the interface it implements using "
"<function><link linkend=\"g-object-class-override-property"
"\">g_object_class_override_property</link></function> instead of "
"<function><link linkend=\"g-object-class-install-property"
"\">g_object_class_install_property</link></function>. The following code "
"snippet shows the modifications needed in the <type>MamanBaz</type> "
"declaration and implementation above: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1151(programlisting)
#, no-wrap
msgid ""
"\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  gint instance_member;\n"
"  gchar *name;\n"
"};\n"
"\n"
"enum\n"
"{\n"
"  PROP_0,\n"
"\n"
"  PROP_NAME\n"
"};\n"
"\n"
"static void\n"
"maman_baz_set_property (GObject      *object,\n"
"                        guint         property_id,\n"
"                        const GValue *value,\n"
"                        GParamSpec   *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"  GObject *obj;\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_free (baz-&gt;name);\n"
"      baz-&gt;name = g_value_dup_string (value);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_get_property (GObject    *object,\n"
"                        guint       prop_id,\n"
"                        GValue     *value,\n"
"                        GParamSpec *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_value_set_string (value, baz-&gt;name);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_class_init (MamanBazClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;set_property = maman_baz_set_property;\n"
"  gobject_class-&gt;get_property = maman_baz_get_property;\n"
"\n"
"  g_object_class_override_property (gobject_class, PROP_NAME, \"name\");\n"
"}\n"
"\n"
msgstr ""

#: tut_howto.xml:1229(title)
msgid "How to create and use signals"
msgstr ""

#: tut_howto.xml:1231(para)
msgid ""
"The signal system which was built in GType is pretty complex and flexible: "
"it is possible for its users to connect at runtime any number of callbacks "
"(implemented in any language for which a binding exists) <placeholder-1/> to "
"any signal and to stop the emission of any signal at any state of the signal "
"emission process. This flexibility makes it possible to use GSignal for much "
"more than just emit signals which can be received by numerous clients."
msgstr ""

#: tut_howto.xml:1237(para)
msgid ""
"A Python callback can be connected to any signal on any C-based GObject."
msgstr ""

#: tut_howto.xml:1248(title)
msgid "Simple use of signals"
msgstr ""

#: tut_howto.xml:1250(para)
msgid ""
"The most basic use of signals is to implement simple event notification: for "
"example, if we have a MamanFile object, and if this object has a write "
"method, we might wish to be notified whenever someone has changed something "
"via our MamanFile instance. The code below shows how the user can connect a "
"callback to the \"changed\" signal. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1257(programlisting)
#, no-wrap
msgid ""
"\n"
"file = g_object_new (MAMAN_FILE_TYPE, NULL);\n"
"\n"
"g_signal_connect (file, \"changed\", G_CALLBACK (changed_event), NULL);\n"
"\n"
"maman_file_write (file, buffer, strlen (buffer));\n"
msgstr ""

#: tut_howto.xml:1266(para)
msgid ""
"The <type>MamanFile</type> signal is registered in the class_init function: "
"<placeholder-1/> and the signal is emitted in <function>maman_file_write</"
"function>: <placeholder-2/> As shown above, you can safely set the details "
"parameter to zero if you do not know what it can be used for. For a "
"discussion of what you could used it for, see <xref linkend=\"signal-detail"
"\"/>"
msgstr ""

#: tut_howto.xml:1269(programlisting)
#, no-wrap
msgid ""
"\n"
"file_signals[CHANGED] = \n"
"  g_signal_newv (\"changed\",\n"
"                 G_TYPE_FROM_CLASS (gobject_class),\n"
"                 G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n"
"                 NULL /* closure */,\n"
"                 NULL /* accumulator */,\n"
"                 NULL /* accumulator data */,\n"
"                 g_cclosure_marshal_VOID__VOID,\n"
"                 G_TYPE_NONE /* return_type */,\n"
"                 0     /* n_params */,\n"
"                 NULL  /* param_types */);\n"
msgstr ""

#: tut_howto.xml:1283(programlisting)
#, no-wrap
msgid ""
"\n"
"void\n"
"maman_file_write (MamanFile    *self,\n"
"                  const guchar *buffer,\n"
"                  gssize        size)\n"
"{\n"
"  /* First write data. */\n"
"\n"
"  /* Then, notify user of data written. */\n"
"  g_signal_emit (self, file_signals[CHANGED], 0 /* details */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:1300(para)
msgid ""
"The signature of the signal handler in the above example is defined as "
"<function>g_cclosure_marshal_VOID__VOID</function>. Its name follows a "
"simple convention which encodes the function parameter and return value "
"types in the function name. Specifically, the value in front of the double "
"underscore is the type of the return value, while the value(s) after the "
"double underscore denote the parameter types."
msgstr ""

#: tut_howto.xml:1309(para)
msgid ""
"The header <filename>gobject/gmarshal.h</filename> defines a set of commonly "
"needed closures that one can use. If you want to have complex marshallers "
"for your signals you should probably use glib-genmarshal to autogenerate "
"them from a file containing their return and parameter types."
msgstr ""

#: tut_howto.xml:136(para)
msgid ""
"Most GTK+ types declare their private fields in the public header with a /* "
"private */ comment, relying on their user's intelligence not to try to play "
"with these fields. Fields not marked private are considered public by "
"default. The /* protected */ comment (same semantics as those of C++) is "
"also used, mainly in the GType library, in code written by Tim Janik. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:143(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /*&lt; private &gt;*/\n"
"  int hsize;\n"
"};\n"
msgstr ""

#: tut_howto.xml:153(para)
msgid ""
"All of Nautilus code and a lot of GNOME libraries use private indirection "
"members, as described by Herb Sutter in his Pimpl articles(see <ulink url="
"\"http://www.gotw.ca/gotw/024.htm\">Compilation Firewalls</ulink> and <ulink "
"url=\"http://www.gotw.ca/gotw/028.htm\">The Fast Pimpl Idiom</ulink>: he "
"summarizes the different issues better than I will). <placeholder-1/"
"><placeholder-2/> The private structure is then defined in the .c file, "
"using the g_type_class_add_private() function to notify the presence of a "
"private memory area for each instance and it can either be retrieved using "
"<function>G_TYPE_INSTANCE_GET_PRIVATE()</function> each time is needed, or "
"assigned to the <literal>priv</literal> member of the instance structure "
"inside the object's <function>init</function> function. <placeholder-3/>"
msgstr ""

#: tut_howto.xml:159(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _MamanBarPrivate MamanBarPrivate;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"    \n"
"  /*&lt; private &gt;*/\n"
"  MamanBarPrivate *priv;\n"
"};\n"
msgstr ""

#: tut_howto.xml:16(title)
msgid "How to define and implement a new GObject"
msgstr ""

#: tut_howto.xml:170(simpara)
msgid ""
"Do not call this <varname>private</varname>, as that is a registered c++ "
"keyword."
msgstr ""

#: tut_howto.xml:18(para)
msgid ""
"Clearly, this is one of the most common questions people ask: they just want "
"to crank code and implement a subclass of a GObject. Sometimes because they "
"want to create their own class hierarchy, sometimes because they want to "
"subclass one of GTK+'s widget. This chapter will focus on the implementation "
"of a subtype of GObject."
msgstr ""

#: tut_howto.xml:180(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  int hsize;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  MamanBarPrivate *priv;\n"
"\n"
"  self-&gt;priv = priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  priv-&gt;hsize = 42;\n"
"}\n"
msgstr ""

#: tut_howto.xml:206(para)
msgid ""
"You don't need to free or allocate the private structure, only the objects "
"or pointers that it may contain. Another advantage of this to the previous "
"version is that is lessens memory fragmentation, as the public and private "
"parts of the instance memory are allocated at once."
msgstr ""

#: tut_howto.xml:216(para)
msgid ""
"Finally, there are different header include conventions. Again, pick one and "
"stick to it. I personally use indifferently any of the two, depending on the "
"codebase I work on: the rule, as always, is consistency. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:221(para)
msgid ""
"Some people add at the top of their headers a number of #include directives "
"to pull in all the headers needed to compile client code. This allows client "
"code to simply #include \"maman-bar.h\"."
msgstr ""

#: tut_howto.xml:226(para)
msgid ""
"Other do not #include anything and expect the client to #include themselves "
"the headers they need before including your header. This speeds up "
"compilation because it minimizes the amount of pre-processor work. This can "
"be used in conjunction with the re-declaration of certain unused types in "
"the client code to minimize compile-time dependencies and thus speed up "
"compilation."
msgstr ""

#: tut_howto.xml:240(title)
msgid "Boilerplate code"
msgstr ""

#: tut_howto.xml:242(para)
msgid ""
"In your code, the first step is to #include the needed headers: depending on "
"your header include strategy, this can be as simple as <literal>#include "
"\"maman-bar.h\"</literal> or as complicated as tens of #include lines ending "
"with <literal>#include \"maman-bar.h\"</literal>: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:247(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright information\n"
" */\n"
"\n"
"#include \"maman-bar.h\"\n"
"\n"
"/* If you use Pimpls, include the private structure \n"
" * definition here. Some people create a maman-bar-private.h header\n"
" * which is included by the maman-bar.c file and which contains the\n"
" * definition for this private structure.\n"
" */\n"
"struct _MamanBarPrivate {\n"
"  int member_1;\n"
"  /* stuff */\n"
"};\n"
"\n"
"/* \n"
" * forward definitions\n"
" */\n"
msgstr ""

#: tut_howto.xml:27(title)
msgid "Boilerplate header code"
msgstr ""

#: tut_howto.xml:270(para)
msgid ""
"Call the <function>G_DEFINE_TYPE</function> macro using the name of the "
"type, the prefix of the functions and the parent GType to reduce the amount "
"of boilerplate needed. This macro will: <placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:276(simpara)
msgid "implement the <function>maman_bar_get_type</function> function"
msgstr ""

#: tut_howto.xml:278(simpara)
msgid "define a parent class pointer accessible from the whole .c file"
msgstr ""

#: tut_howto.xml:282(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
msgstr ""

#: tut_howto.xml:287(para)
msgid ""
"It is also possible to use the <function>G_DEFINE_TYPE_WITH_CODE</function> "
"macro to control the get_type function implementation - for instance, to add "
"a call to <function>G_IMPLEMENT_INTERFACE</function> macro which will call "
"the <function>g_type_implement_interface</function> function."
msgstr ""

#: tut_howto.xml:29(para)
msgid ""
"The first step before writing the code for your GObject is to write the "
"type's header which contains the needed type, function and macro "
"definitions. Each of these elements is nothing but a convention which is "
"followed not only by GTK+'s code but also by most users of GObject. If you "
"feel the need not to obey the rules stated below, think about it twice: "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:297(title)
msgid "Object Construction"
msgstr ""

#: tut_howto.xml:299(para)
msgid ""
"People often get confused when trying to construct their GObjects because of "
"the sheer number of different ways to hook into the objects's construction "
"process: it is difficult to figure which is the <emphasis>correct</"
"emphasis>, recommended way."
msgstr ""

#: tut_howto.xml:305(para)
msgid ""
"<xref linkend=\"gobject-construction-table\"/> shows what user-provided "
"functions are invoked during object instantiation and in which order they "
"are invoked. A user looking for the equivalent of the simple C++ constructor "
"function should use the instance_init method. It will be invoked after all "
"the parent's instance_init functions have been invoked. It cannot take "
"arbitrary construction parameters (as in C++) but if your object needs "
"arbitrary parameters to complete initialization, you can use construction "
"properties."
msgstr ""

#: tut_howto.xml:315(para)
msgid ""
"Construction properties will be set only after all instance_init functions "
"have run. No object reference will be returned to the client of "
"<function><link linkend=\"g-object-new\">g_object_new</link></function> "
"until all the construction properties have been set."
msgstr ""

#: tut_howto.xml:321(para)
msgid ""
"As such, I would recommend writing the following code first: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:323(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self); \n"
"\n"
"  /* initialize all public and private members to reasonable default values. */\n"
"\n"
"  /* If you need specific construction properties to complete initialization,\n"
"   * delay initialization completion until the property is set. \n"
"   */\n"
"}\n"
msgstr ""

#: tut_howto.xml:338(para)
msgid ""
"Now, if you need special construction properties, install the properties in "
"the class_init function, override the set and get methods and implement the "
"get and set methods as described in <xref linkend=\"gobject-properties\"/>. "
"Make sure that these properties use a construct only <link linkend="
"\"GParamSpec\"><type>GParamSpec</type></link> by setting the param spec's "
"flag field to G_PARAM_CONSTRUCT_ONLY: this helps GType ensure that these "
"properties are not set again later by malicious user code. <placeholder-1/> "
"If you need this, make sure you can build and run code similar to the code "
"shown above. Make sure your construct properties can set correctly during "
"construction, make sure you cannot set them afterwards and make sure that if "
"your users do not call <function><link linkend=\"g-object-new"
"\">g_object_new</link></function> with the required construction properties, "
"these will be initialized with the default values."
msgstr ""

#: tut_howto.xml:344(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"  GParamSpec *pspec;\n"
"\n"
"  gobject_class-&gt;set_property = bar_set_property;\n"
"  gobject_class-&gt;get_property = bar_get_property;\n"
"\n"
"  pspec = g_param_spec_string (\"maman\",\n"
"                                          \"Maman construct prop\",\n"
"                                          \"Set maman's name\",\n"
"                                          \"no-name-set\" /* default value */,\n"
"                                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_MAMAN,\n"
"                                   pspec);\n"
"}\n"
msgstr ""

#: tut_howto.xml:37(para)
msgid ""
"If your users are a bit accustomed to GTK+ code or any GLib code, they will "
"be a bit surprised and getting used to the conventions you decided upon will "
"take time (money) and will make them grumpy (not a good thing)"
msgstr ""

#: tut_howto.xml:370(para)
msgid ""
"I consider good taste to halt program execution if a construction property "
"is set its default value. This allows you to catch client code which does "
"not give a reasonable value to the construction properties. Of course, you "
"are free to disagree but you should have a good reason to do so."
msgstr ""

#: tut_howto.xml:377(para)
msgid ""
"Some people sometimes need to construct their object but only after the "
"construction properties have been set. This is possible through the use of "
"the constructor class method as described in <xref linkend=\"gobject-"
"instantiation\"/> or, more simply, using the constructed class method "
"available since GLib 2.12."
msgstr ""

#: tut_howto.xml:387(title)
msgid "Object Destruction"
msgstr ""

#: tut_howto.xml:389(para)
msgid ""
"Again, it is often difficult to figure out which mechanism to use to hook "
"into the object's destruction process: when the last <function><link linkend="
"\"g-object-unref\">g_object_unref</link></function> function call is made, a "
"lot of things happen as described in <xref linkend=\"gobject-destruction-"
"table\"/>."
msgstr ""

#: tut_howto.xml:397(para)
msgid ""
"The destruction process of your object might be split in two different "
"phases: dispose and the finalize. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:400(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  GObject *an_object;\n"
"\n"
"  gchar *a_string;\n"
"};\n"
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
"\n"
"static void\n"
"maman_bar_dispose (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  /* \n"
"   * In dispose, you are supposed to free all types referenced from this\n"
"   * object which might themselves hold a reference to self. Generally,\n"
"   * the most simple solution is to unref all members on which you own a \n"
"   * reference.\n"
"   */\n"
"\n"
"  /* dispose might be called multiple times, so we must guard against\n"
"   * calling g_object_unref() on an invalid GObject.\n"
"   */\n"
"  if (self-&gt;priv-&gt;an_object)\n"
"    {\n"
"      g_object_unref (self-&gt;priv-&gt;an_object);\n"
"\n"
"      self-&gt;priv-&gt;an_object = NULL;\n"
"    }\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;dispose (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_finalize (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  g_free (self-&gt;priv-&gt;a_string);\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;finalize (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;dispose = maman_bar_dispose;\n"
"  gobject_class-&gt;finalize = maman_bar_finalize;\n"
"\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self);\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  self-&gt;priv-&gt;an_object = g_object_new (MAMAN_TYPE_BAZ, NULL);\n"
"  self-&gt;priv-&gt;a_string = g_strdup (\"Maman\");\n"
"}\n"
msgstr ""

#: tut_howto.xml:41(para)
msgid ""
"You must assess the fact that these conventions might have been designed by "
"both smart and experienced people: maybe they were at least partly right. "
"Try to put your ego aside."
msgstr ""

#: tut_howto.xml:47(para)
msgid ""
"Pick a name convention for your headers and source code and stick to it: "
"<placeholder-1/> Some people like the first two solutions better: it makes "
"reading file names easier for those with poor eyesight."
msgstr ""

#: tut_howto.xml:471(para)
msgid ""
"Add similar code to your GObject, make sure the code still builds and runs: "
"dispose and finalize must be called during the last unref."
msgstr ""

#: tut_howto.xml:476(para)
msgid ""
"It is possible that object methods might be invoked after dispose is run and "
"before finalize runs. GObject does not consider this to be a program error: "
"you must gracefully detect this and neither crash nor warn the user."
msgstr ""

#: tut_howto.xml:485(title)
msgid "Object methods"
msgstr ""

#: tut_howto.xml:487(para)
msgid ""
"Just as with C++, there are many different ways to define object methods and "
"extend them: the following list and sections draw on C++ vocabulary. "
"(Readers are expected to know basic C++ buzzwords. Those who have not had to "
"write C++ code recently can refer to e.g. <ulink url=\"http://www.cplusplus."
"com/doc/tutorial/\"/> to refresh their memories.) <placeholder-1/>"
msgstr ""

#: tut_howto.xml:495(para)
msgid "non-virtual public methods,"
msgstr ""

#: tut_howto.xml:498(para)
msgid "virtual public methods and"
msgstr ""

#: tut_howto.xml:50(para)
msgid ""
"use a dash to separate the prefix from the typename: <filename>maman-bar.h</"
"filename> and <filename>maman-bar.c</filename> (this is the convention used "
"by Nautilus and most GNOME libraries)."
msgstr ""

#: tut_howto.xml:501(para)
msgid "virtual private methods"
msgstr ""

#: tut_howto.xml:508(title)
msgid "Non-virtual public methods"
msgstr ""

#: tut_howto.xml:510(para)
msgid ""
"These are the simplest: you want to provide a simple method which can act on "
"your object. All you need to do is to provide a function prototype in the "
"header and an implementation of that prototype in the source file. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:515(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in the header. */\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in the source file */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  /* do stuff here. */\n"
"}\n"
msgstr ""

#: tut_howto.xml:53(para)
msgid ""
"use an underscore to separate the prefix from the typename: "
"<filename>maman_bar.h</filename> and <filename>maman_bar.c</filename>."
msgstr ""

#: tut_howto.xml:530(para)
msgid "There is really nothing scary about this."
msgstr ""

#: tut_howto.xml:534(title)
msgid "Virtual public methods"
msgstr ""

#: tut_howto.xml:536(para)
msgid ""
"This is the preferred way to create polymorphic GObjects. All you need to do "
"is to define the common method and its class function in the public header, "
"implement the common method in the source file and re-implement the class "
"function in each object which inherits from you. <placeholder-1/> The code "
"above simply redirects the do_action call to the relevant class function. "
"Some users, concerned about performance, do not provide the "
"<function>maman_bar_do_action</function> wrapper function and require users "
"to dereference the class pointer themselves. This is not such a great idea "
"in terms of encapsulation and makes it difficult to change the object's "
"implementation afterwards, should this be needed."
msgstr ""

#: tut_howto.xml:542(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* stuff */\n"
"  void (*do_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in maman-bar.c */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:56(para)
msgid ""
"Do not separate the prefix from the typename: <filename>mamanbar.h</"
"filename> and <filename>mamanbar.c</filename>. (this is the convention used "
"by GTK+)"
msgstr ""

#: tut_howto.xml:572(para)
msgid ""
"Other users, also concerned by performance issues, declare the "
"<function>maman_bar_do_action</function> function inline in the header file. "
"This, however, makes it difficult to change the object's implementation "
"later (although easier than requiring users to directly dereference the "
"class function) and is often difficult to write in a portable way (the "
"<emphasis>inline</emphasis> keyword is part of the C99 standard but not "
"every compiler supports it)."
msgstr ""

#: tut_howto.xml:582(para)
msgid ""
"In doubt, unless a user shows you hard numbers about the performance cost of "
"the function call, just implement <function>maman_bar_do_action</function> "
"in the source file."
msgstr ""

#: tut_howto.xml:588(para)
msgid ""
"Please, note that it is possible for you to provide a default implementation "
"for this class method in the object's <function>class_init</function> "
"function: initialize the klass-&gt;do_action field to a pointer to the "
"actual implementation. You can also make this class method pure virtual by "
"initializing the klass-&gt;do_action field to NULL: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:595(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_real_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* Default implementation for the virtual method. */\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (BarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_action_two = maman_bar_real_do_action_two;\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_one (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_one (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_two (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:6(title)
msgid "Tutorial"
msgstr ""

#: tut_howto.xml:632(title)
msgid "Virtual private Methods"
msgstr ""

#: tut_howto.xml:634(para)
msgid ""
"These are very similar to Virtual Public methods. They just don't have a "
"public function to call the function directly. The header file contains only "
"a declaration of the class function: <placeholder-1/> These class functions "
"are often used to delegate part of the job to child classes: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:638(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent;\n"
"\n"
"  /* stuff */\n"
"  void (* helper_do_specific_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_any_action (MamanBar *self, /* parameters */);\n"
msgstr ""

#: tut_howto.xml:64(para)
msgid ""
"When you need some private (internal) declarations in several (sub)classes, "
"you can define them in a private header file which is often named by "
"appending the <emphasis>private</emphasis> keyword to the public header "
"name. For example, one could use <filename>maman-bar-private.h</filename>, "
"<filename>maman_bar_private.h</filename> or <filename>mamanbarprivate.h</"
"filename>. Typically, such private header files are not installed."
msgstr ""

#: tut_howto.xml:652(programlisting)
#, no-wrap
msgid ""
"\n"
"/* this accessor function is static: it is not exported outside of this file. */\n"
"static void \n"
"maman_bar_do_specific_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_specific_action (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_any_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* random code here */\n"
"\n"
"  /* \n"
"   * Try to execute the requested action. Maybe the requested action\n"
"   * cannot be implemented here. So, we delegate its implementation\n"
"   * to the child class:\n"
"   */\n"
"  maman_bar_do_specific_action (self, /* parameters */);\n"
"\n"
"  /* other random code here */\n"
"}\n"
msgstr ""

#: tut_howto.xml:677(para)
msgid ""
"Again, it is possible to provide a default implementation for this private "
"virtual class function: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:680(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_specific_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_specific_action_two = maman_bar_real_do_specific_action_two;\n"
"}\n"
msgstr ""

#: tut_howto.xml:693(para)
msgid ""
"Children can then implement the subclass with code such as: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:695(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_subtype_class_init (MamanBarSubTypeClass *klass)\n"
"{\n"
"  MamanBarClass *bar_class = MAMAN_BAR_CLASS (klass);\n"
"\n"
"  /* implement pure virtual class function. */\n"
"  bar_class-&gt;do_specific_action_one = maman_bar_subtype_do_specific_action_one;\n"
"}\n"
msgstr ""

#: tut_howto.xml:710(title)
msgid "Chaining up"
msgstr ""

#: tut_howto.xml:712(para)
msgid ""
"Chaining up is often loosely defined by the following set of conditions: "
"<placeholder-1/> There are many uses to this idiom: <placeholder-2/> I am "
"personally not really convinced any of the last two uses are really a good "
"idea but since this programming idiom is often used, this section attempts "
"to explain how to implement it."
msgstr ""

#: tut_howto.xml:715(para)
msgid ""
"Parent class A defines a public virtual method named <function>foo</"
"function> and provides a default implementation."
msgstr ""

#: tut_howto.xml:717(para)
msgid "Child class B re-implements method <function>foo</function>."
msgstr ""

#: tut_howto.xml:718(para)
msgid ""
"In the method B::foo, the child class B calls its parent class method A::foo."
msgstr ""

#: tut_howto.xml:722(para)
msgid ""
"You need to change the behaviour of a class without modifying its code. You "
"create a subclass to inherit its implementation, re-implement a public "
"virtual method to modify the behaviour slightly and chain up to ensure that "
"the previous behaviour is not really modified, just extended."
msgstr ""

#: tut_howto.xml:726(para)
msgid ""
"You are lazy, you have access to the source code of the parent class but you "
"don't want to modify it to add method calls to new specialized method calls: "
"it is faster to hack the child class to chain up than to modify the parent "
"to call down."
msgstr ""

#: tut_howto.xml:729(para)
msgid ""
"You need to implement the Chain Of Responsibility pattern: each object of "
"the inheritance tree chains up to its parent (typically, at the beginning or "
"the end of the method) to ensure that they each handler is run in turn."
msgstr ""

#: tut_howto.xml:737(para)
msgid ""
"To explicitly chain up to the implementation of the virtual method in the "
"parent class, you first need a handle to the original parent class "
"structure. This pointer can then be used to access the original class "
"function pointer and invoke it directly. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:742(para)
msgid ""
"The <emphasis>original</emphasis> adjective used in this sentence is not "
"innocuous. To fully understand its meaning, you need to recall how class "
"structures are initialized: for each object type, the class structure "
"associated to this object is created by first copying the class structure of "
"its parent type (a simple <function>memcpy</function>) and then by invoking "
"the class_init callback on the resulting class structure. Since the "
"class_init callback is responsible for overwriting the class structure with "
"the user re-implementations of the class methods, we cannot merely use the "
"modified copy of the parent class structure stored in our derived instance. "
"We want to get a copy of the class structure of an instance of the parent "
"class."
msgstr ""

#: tut_howto.xml:75(para)
msgid ""
"The basic conventions for any header which exposes a GType are described in "
"<xref linkend=\"gtype-conventions\"/>. Most GObject-based code also obeys "
"one of of the following conventions: pick one and stick to it. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:755(para)
msgid ""
"The function <function><link linkend=\"g-type-class-peek-parent"
"\">g_type_class_peek_parent</link></function> is used to access the original "
"parent class structure. Its input is a pointer to the class of the derived "
"object and it returns a pointer to the original parent class structure. The "
"code below shows how you could use it: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:758(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"b_method_to_call (B *obj, int a)\n"
"{\n"
"  BClass *klass;\n"
"  AClass *parent_class;\n"
"\n"
"  klass = B_GET_CLASS (obj);\n"
"  parent_class = g_type_class_peek_parent (klass);\n"
"\n"
"  /* do stuff before chain up */\n"
"\n"
"  parent_class-&gt;method_to_call (obj, a);\n"
"\n"
"  /* do stuff after chain up */\n"
"}\n"
msgstr ""

#: tut_howto.xml:783(title)
msgid "How to define and implement interfaces"
msgstr ""

#: tut_howto.xml:786(title)
msgid "How to define interfaces"
msgstr ""

#: tut_howto.xml:788(para)
msgid ""
"The bulk of interface definition has already been shown in <xref linkend="
"\"gtype-non-instantiable-classed\"/> but I feel it is needed to show exactly "
"how to create an interface."
msgstr ""

#: tut_howto.xml:793(para)
msgid ""
"As above, the first step is to get the header right: <placeholder-1/> This "
"code is the same as the code for a normal <link linkend=\"GType"
"\"><type>GType</type></link> which derives from a <link linkend=\"GObject"
"\"><type>GObject</type></link> except for a few details: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:795(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_IBAZ_H__\n"
"#define __MAMAN_IBAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_IBAZ                 (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"\n"
"typedef struct _MamanIbaz               MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface      MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface\n"
"{\n"
"  GTypeInterface parent_iface;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
"\n"
"#endif /* __MAMAN_IBAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:8(para)
msgid ""
"This chapter tries to answer the real-life questions of users and presents "
"the most common scenario use cases I could come up with. The use cases are "
"presented from most likely to less likely."
msgstr ""

#: tut_howto.xml:80(para)
msgid ""
"If you want to declare a type named bar with prefix maman, name the type "
"instance <function>MamanBar</function> and its class "
"<function>MamanBarClass</function> (name is case-sensitive). It is customary "
"to declare them with code similar to the following: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:826(para)
msgid ""
"The <function>_GET_CLASS</function> macro is called "
"<function>_GET_INTERFACE</function> and not implemented with <function><link "
"linkend=\"G_TYPE_INSTANCE_GET_CLASS\">G_TYPE_INSTANCE_GET_CLASS</link></"
"function> but with <function><link linkend=\"G_TYPE_INSTANCE_GET_INTERFACE"
"\">G_TYPE_INSTANCE_GET_INTERFACE</link></function>."
msgstr ""

#: tut_howto.xml:831(para)
msgid ""
"The instance type, <type>MamanIbaz</type> is not fully defined: it is used "
"merely as an abstract type which represents an instance of whatever object "
"which implements the interface."
msgstr ""

#: tut_howto.xml:836(para)
msgid ""
"The parent of the <type>MamanIbazInterface</type> is not <type>GObjectClass</"
"type> but <type>GTypeInterface</type>."
msgstr ""

#: tut_howto.xml:843(para)
msgid ""
"The implementation of the <type>MamanIbaz</type> type itself is trivial: "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:846(para)
msgid ""
"<function>maman_ibaz_get_type</function> registers the type in the type "
"system."
msgstr ""

#: tut_howto.xml:849(para)
msgid ""
"<function>maman_ibaz_base_init</function> is expected to register the "
"interface's signals if there are any (we will see a bit (later how to use "
"them). Make sure to use a static local boolean variable to make sure not to "
"run the initialization code twice (as described in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, <function>base_init</function> is run once "
"for each interface implementation instantiation)"
msgstr ""

#: tut_howto.xml:85(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright/Licensing information.\n"
" */\n"
"\n"
"/* inclusion guard */\n"
"#ifndef __MAMAN_BAR_H__\n"
"#define __MAMAN_BAR_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"/*\n"
" * Potentially, include other headers on which this header depends.\n"
" */\n"
"\n"
"/*\n"
" * Type macros.\n"
" */\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_IS_BAR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
"\n"
"typedef struct _MamanBar        MamanBar;\n"
"typedef struct _MamanBarClass   MamanBarClass;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /* instance members */\n"
"};\n"
"\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* class members */\n"
"};\n"
"\n"
"/* used by MAMAN_TYPE_BAR */\n"
"GType maman_bar_get_type (void);\n"
"\n"
"/*\n"
" * Method definitions.\n"
" */\n"
"\n"
"#endif /* __MAMAN_BAR_H__ */\n"
msgstr ""

#: tut_howto.xml:856(para)
msgid ""
"<function>maman_ibaz_do_action</function> dereferences the class structure "
"to access its associated class function and calls it."
msgstr ""

#: tut_howto.xml:860(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_class)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      /* add properties and signals to the interface here */\n"
"\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
"\n"
"GType\n"
"maman_ibaz_get_type (void)\n"
"{\n"
"  static GType iface_type = 0;\n"
"  if (iface_type == 0)\n"
"    {\n"
"      static const GTypeInfo info = {\n"
"        sizeof (MamanIbazInterface),\n"
"        maman_ibaz_base_init,   /* base_init */\n"
"        NULL,   /* base_finalize */\n"
"      };\n"
"\n"
"      iface_type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbaz\",\n"
"                                           &amp;info, 0);\n"
"    }\n"
"\n"
"  return iface_type;\n"
"}\n"
"\n"
"void\n"
"maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_IBAZ (self));\n"
"\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""

#: tut_howto.xml:905(title)
msgid "How To define implement an Interface?"
msgstr ""

#: tut_howto.xml:907(para)
msgid "Once the interface is defined, implementing it is rather trivial."
msgstr ""

#: tut_howto.xml:911(para)
msgid ""
"The first step is to define a normal GObject class, like: <placeholder-1/> "
"There is clearly nothing specifically weird or scary about this header: it "
"does not define any weird API or derives from a weird type."
msgstr ""

#: tut_howto.xml:913(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_BAZ_H__\n"
"#define __MAMAN_BAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_BAZ             (maman_baz_get_type ())\n"
"#define MAMAN_BAZ(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAZ, Mamanbaz))\n"
"#define MAMAN_IS_BAZ(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"#define MAMAN_IS_BAZ_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"\n"
"\n"
"typedef struct _MamanBaz        MamanBaz;\n"
"typedef struct _MamanBazClass   MamanBazClass;\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  int instance_member;\n"
"};\n"
"\n"
"struct _MamanBazClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"};\n"
"\n"
"GType maman_baz_get_type (void);\n"
"\n"
"#endif /* __MAMAN_BAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:950(para)
msgid ""
"The second step is to implement <type>MamanBaz</type> by defining its GType. "
"Instead of using <function>G_DEFINE_TYPE</function> we use "
"<function>G_DEFINE_TYPE_WITH_CODE</function> and the "
"<function>G_IMPLEMENT_INTERFACE</function> macros. <placeholder-1/> This "
"definition is very much like all the similar functions we looked at "
"previously. The only interface-specific code present here is the call to "
"<function>G_IMPLEMENT_INTERFACE</function>."
msgstr ""

#: tut_howto.xml:955(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_ibaz_interface_init (MamanIbazInterface *iface);\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init));\n"
msgstr ""

#: tut_howto.xml:967(para)
msgid ""
"Classes can implement multiple interfaces by using multiple calls to "
"<function>G_IMPLEMENT_INTERFACE</function> inside the call to "
"<function>G_DEFINE_TYPE_WITH_CODE</function>."
msgstr ""

#: tut_howto.xml:971(para)
msgid ""
"<function>maman_baz_interface_init</function>, the interface initialization "
"function: inside it every virtual method of the interface must be assigned "
"to its implementation: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:975(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_baz_do_action (MamanBaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = baz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_baz_init (MamanBaz *self)\n"
"{\n"
"  MamanBaz *self = MAMAN_BAZ (instance);\n"
"  self-&gt;instance_member = 0xdeadbeaf;\n"
"}\n"
msgstr ""

#: tut_intro.xml:112(para)
msgid ""
"Now, let's say we want to call the C function <function>function_foo</"
"function> from a Python program. To do this, the Python interpreter needs "
"to: <placeholder-1/>"
msgstr ""
"现在我们看看如何从一个Python程序中调用C函数<function>function_foo</"
"function>。为了做到这一点，Python解释器需要做：<placeholder-1/>"

#: tut_intro.xml:116(para)
msgid ""
"Find where the function is located. This probably means finding the binary "
"generated by the C compiler which exports this function."
msgstr ""
"找到函数所处的位置。这通常意味着在导出这个函数的二进制文件中进行搜寻，这个二"
"进制文件是由C编译器生成的。"

#: tut_intro.xml:118(para)
msgid "Load the code of the function in executable memory."
msgstr "在可执行的内存中，载入有关这个函数的机器码。"

#: tut_intro.xml:119(para)
msgid ""
"Convert the Python parameters to C-compatible parameters before calling the "
"function."
msgstr "在调用这个函数前，将Python的参数转换为C兼容的参数。"

#: tut_intro.xml:12(para)
msgid "object-oriented C-based APIs and"
msgstr "一套面向对象的基于C语言的API和"

#: tut_intro.xml:121(para)
msgid "Call the function with the right calling convention."
msgstr "使用正确的调用约定（calling convention）调用这个函数。"

#: tut_intro.xml:122(para)
msgid ""
"Convert the return values of the C function to Python-compatible variables "
"to return them to the Python code."
msgstr "将C函数的返回值转换成Python兼容的变量并将其返回到Python代码中。"

#: tut_intro.xml:127(para)
msgid ""
"The process described above is pretty complex and there are a lot of ways to "
"make it entirely automatic and transparent to C and Python programmers: "
"<placeholder-1/> The greatest advantage of the solution implemented by GType "
"is that the glue code sitting at the runtime domain boundaries is written "
"once: the figure below states this more clearly. <placeholder-2/> Currently, "
"there exist at least Python and Perl generic glue code which makes it "
"possible to use C objects written with GType directly in Python or Perl, "
"with a minimum amount of work: there is no need to generate huge amounts of "
"glue code either automatically or by hand."
msgstr ""
"上面所描述的处理过程是相当复杂的。不过有很多种方法可以使它完全自动化，并且使"
"得这个过程对C和Python程序员来说都是透明的：<placeholder-1/>这个由GType实现的"
"解决方案的最大的优势在于运行环境边界之间的粘合代码只写一次就够了。下图会说明"
"的更加清楚：<placeholder-2/>当前，至少Python和Perl的通用粘合代码已经能够直接"
"在Python或Perl上使用GType编写的C对象，只要最少的工作量即可：没有必要去自动或"
"手动生成大量的粘合代码。"

#: tut_intro.xml:13(para)
msgid ""
"automatic transparent API bindings to other compiled or interpreted "
"languages."
msgstr "到其他编译或解释型语言的自动透明的API绑定"

#: tut_intro.xml:131(para)
msgid ""
"The first solution is to write by hand a lot of glue code, once for each "
"function exported or imported, which does the Python-to-C parameter "
"conversion and the C-to-Python return value conversion. This glue code is "
"then linked with the interpreter which allows Python programs to call Python "
"functions which delegate work to C functions."
msgstr ""
"第一个解决方案是手动编写一些“粘合代码”，当每个函数被导入或导出时，使用这些代"
"码将Python的参数转换为C兼容的参数，并将C的返回值转换为Python兼容的返回值。这"
"个粘合代码将被链接到解释器上，从而允许Python程序调用那些和C函数协同工作的"
"Python函数。"

#: tut_intro.xml:135(para)
msgid ""
"Another, nicer solution is to automatically generate the glue code, once for "
"each function exported or imported, with a special compiler which reads the "
"original function signature."
msgstr ""
"另一个更好的解决方案是自动产生粘合代码，当每个函数被导入或导出时，使用一个特"
"殊的编译器来读取原始的函数签名。"

#: tut_intro.xml:138(para)
msgid ""
"The solution used by GLib is to use the GType library which holds at runtime "
"a description of all the objects manipulated by the programmer. This so-"
"called <emphasis>dynamic type</emphasis><placeholder-1/> library is then "
"used by special generic glue code to automatically convert function "
"parameters and function calling conventions between different runtime "
"domains."
msgstr ""
"GLib用的解决方案是，使用GType库来保存在当前运行环境中的所有由程序员使用的对象"
"的描述。这些<emphasis>动态类型</emphasis><placeholder-1/>库将被特殊的“通用粘"
"合代码”使用，用来在不同的运行环境之间自动转换函数参数和函数调用约定。"

#: tut_intro.xml:141(para)
msgid ""
"There are numerous different implementations of dynamic type systems: all C+"
"+ compilers have one, Java and .NET have one too. A dynamic type system "
"allows you to get information about every instantiated object at runtime. It "
"can be implemented by a process-specific database: every new object created "
"registers the characteristics of its associated type in the type system. It "
"can also be implemented by introspection interfaces. The common point "
"between all these different type systems and implementations is that they "
"all allow you to query for object metadata at runtime."
msgstr ""
"动态类型系统有很多种不同的实现方式：C++编译器是一种，Java和.NET也是一种。一个"
"动态类型系统允许你在运行的时候获得每个实例化对象的信息。它可以被实现为一个特"
"定于进程的数据库：每一个新创建的对象将它对应的类型特征注册到类型系统中。它也"
"可以被实现为一套introspection（译注：在计算机科学领域，type introspection是指"
"程序能够在运行的时候检查一个对象的类型或属性的能力——摘自Wiki）的接口。所有这"
"些不同的类型系统及其实现方式的共同点是：允许你在运行时查询对象的元数据。"

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:159(None)
msgid "@@image: 'glue.png'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:162(None)
msgid "@@image: 'glue.jpg'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#: tut_intro.xml:172(para)
msgid ""
"Although that goal was arguably laudable, its pursuit has had a major "
"influence on the whole GType/GObject library. C programmers are likely to be "
"puzzled at the complexity of the features exposed in the following chapters "
"if they forget that the GType/GObject library was not only designed to offer "
"OO-like features to C programmers but also transparent cross-language "
"interoperability."
msgstr ""
"尽管这个目标非常值得称赞，对该目标的追求影响了整个GType/GObject库的设计，不过"
"C程序员还是很可能会对接下来几章所揭露的特性的复杂性感到困惑，如果他们忘了"
"GType/GObject库的设计不仅仅是为了向C程序员提供面向对象的特性，也是为了透明的"
"跨语言互通性。"

#: tut_intro.xml:18(para)
msgid ""
"A lot of programmers are used to working with compiled-only or dynamically "
"interpreted-only languages and do not understand the challenges associated "
"with cross-language interoperability. This introduction tries to provide an "
"insight into these challenges and briefly describes the solution chosen by "
"GLib."
msgstr ""
"很多程序员已经习惯于只使用编译型或只使用动态解释型的编程语言。他们并不清楚跨"
"语言的互操作性所面对的问题。本段介绍试图对这些问题提供一个解答，并重点描述"
"Glib所选择的解决方案。"

#: tut_intro.xml:25(para)
msgid ""
"The following chapters go into greater detail into how GType and GObject "
"work and how you can use them as a C programmer. It is useful to keep in "
"mind that allowing access to C objects from other interpreted languages was "
"one of the major design goals: this can often explain the sometimes rather "
"convoluted APIs and features present in this library."
msgstr ""
"下面的章节将深入细节的阐述：GType和GObject是怎样工作的？作为一个C语言程序员该"
"怎样使用它们？值得注意的是允许其他解释型语言访问C语言对象是设计的主要目标之"
"一：这也可以解释有些相当复杂的API和特性会出现在这个库中。"

#: tut_intro.xml:34(title)
msgid "Data types and programming"
msgstr "数据类型和编程"

#: tut_intro.xml:36(para)
msgid ""
"One could say (I have seen such definitions used in some textbooks on "
"programming language theory) that a programming language is merely a way to "
"create data types and manipulate them. Most languages provide a number of "
"language-native types and a few primitives to create more complex types "
"based on these primitive types."
msgstr ""
"有人会说(这样的定义我在一些编程语言理论的书上也看到过)：编程语言只是一种创建"
"数据类型并使用它们的方式。绝大多数语言提供一些语言原生的类型和一些原语用以在"
"原生类型的基础上创建更多复杂的类型。"

#: tut_intro.xml:43(para)
msgid ""
"In C, the language provides types such as <emphasis>char</emphasis>, "
"<emphasis>long</emphasis>, <emphasis>pointer</emphasis>. During compilation "
"of C code, the compiler maps these language types to the compiler's target "
"architecture machine types. If you are using a C interpreter (I have never "
"seen one myself but it is possible :), the interpreter (the program which "
"interprets the source code and executes it) maps the language types to the "
"machine types of the target machine at runtime, during the program execution "
"(or just before execution if it uses a Just In Time compiler engine)."
msgstr ""
"C语言提供诸如<emphasis>char</emphasis>, <emphasis>long</emphasis>, "
"<emphasis>pointer</emphasis>之类的类型。在C代码的编译过程中，编译器将这些语言"
"类型映射到编译器目标体系的机器类型上。如果你正在使用一个C语言解释器(虽然我自"
"己从没见过C语言解释器，但这是可行的。)，这个解释器(解释器是一种解释源代码并执"
"行的程序)会在程序执行过程中，将语言类型映射到目标机器的机器类型上。(或者，如"
"果解释器使用即时编译引擎（Just In Time compiler engine）的话，解释器会在程序"
"执行之前，做这种映射。)"

#: tut_intro.xml:52(para)
msgid ""
"Perl and Python are interpreted languages which do not really provide type "
"definitions similar to those used by C. Perl and Python programmers "
"manipulate variables and the type of the variables is decided only upon the "
"first assignment or upon the first use which forces a type on the variable. "
"The interpreter also often provides a lot of automatic conversions from one "
"type to the other. For example, in Perl, a variable which holds an integer "
"can be automatically converted to a string given the required context: "
"<placeholder-1/> Of course, it is also often possible to explicitly specify "
"conversions when the default conversions provided by the language are not "
"intuitive."
msgstr ""
"Perl和Python都是解释型语言，它们并不真正提供类似于C语言那样的类型定义。Perl和"
"Python程序员使用变量时，变量的类型只取决于首次赋值或使用时设置的变量类型。解"
"释器通常也提供从一种类型到另一种类型的自动转换。例如，在Perl语言中，一个保存"
"整型值的变量可以采用如下方式自动转化成一个字符串：<placeholder-1/>当然，当语"
"言默认提供的转换不够直观的时候，使用显式定义的转换通常也是可以的。"

#: tut_intro.xml:59(programlisting)
#, no-wrap
msgid ""
"\n"
"my $tmp = 10;\n"
"print \"this is an integer converted to a string:\" . $tmp . \"\\n\";\n"
msgstr ""

#: tut_intro.xml:6(title)
msgid "Background"
msgstr "背景"

#: tut_intro.xml:70(title)
msgid "Exporting a C API"
msgstr "导出一个C语言的API"

#: tut_intro.xml:72(para)
msgid ""
"C APIs are defined by a set of functions and global variables which are "
"usually exported from a binary. C functions have an arbitrary number of "
"arguments and one return value. Each function is thus uniquely identified by "
"the function name and the set of C types which describe the function "
"arguments and return value. The global variables exported by the API are "
"similarly identified by their name and their type."
msgstr ""
"C语言的API通常是从一个二进制文件中导出的函数和全局变量的集合。C函数包含任意个"
"数的参数和一个返回值。每个函数被它的名字所唯一标识，C语言类型的集合用于描述函"
"数的参数和返回值。API中导出的全局变量也以类似的方式，被它们的名字和类型所标识"

#: tut_intro.xml:8(para)
msgid ""
"GObject, and its lower-level type system, GType, are used by GTK+ and most "
"GNOME libraries to provide: <placeholder-1/>"
msgstr ""
"GObject和它的底层类型系统GType，被GTK+和大多数GNOME库所使用，它们提供了以下功"
"能：<placeholder-1/>"

#: tut_intro.xml:80(para)
msgid ""
"A C API is thus merely defined by a set of names to which a set of types are "
"associated. If you know the function calling convention and the mapping of "
"the C types to the machine types used by the platform you are on, you can "
"resolve the name of each function to find where the code associated to this "
"function is located in memory, and then construct a valid argument list for "
"the function. Finally, all you have to do is trigger a call to the target C "
"function with the argument list."
msgstr ""
"因此，C语言API只是一组类型所关联的名字的集合。如果知道你所工作平台上的函数调"
"用约定（calling convention）以及C语言类型到机器类型的映射，你就能够通过函数的"
"名字，在内存中找到这个函数所对应的机器码，并为这个函数构建一个合法的参数链"
"表。最终，你要做的就是使用这个参数链表触发一个目标C函数的调用。"

#: tut_intro.xml:88(para)
msgid ""
"For the sake of discussion, here is a sample C function and the associated "
"32 bit x86 assembly code generated by GCC on my Linux box: <placeholder-1/> "
"The assembly code shown above is pretty straightforward: the first "
"instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit "
"integer on the stack and calls <function>function_foo</function>. As you can "
"see, C function calls are implemented by gcc by native function calls (this "
"is probably the fastest implementation possible)."
msgstr ""
"为了更好的讨论，这里有个简单的C函数以及它对应的32位x86汇编代码，这些汇编代码"
"是用Linux上的GCC生成的。<placeholder-1/>上面所示的汇编代码是相当简明的：首先"
"将十六进制值0xa(十进制值10)作为一个32位的整数压入堆栈中，然后再调用"
"<function>function_foo</function>。就像你看到的那样，C函数调用被gcc实现为本地"
"函数调用。(这可能也是最快速的实现了)"

#: tut_intro.xml:91(programlisting)
#, no-wrap
msgid ""
"\n"
"static void function_foo (int foo)\n"
"{}\n"
"\n"
"int main (int argc, char *argv[])\n"
"{\n"
"\n"
"        function_foo (10);\n"
"\n"
"        return 0;\n"
"}\n"
"\n"
"push   $0xa\n"
"call   0x80482f4 &lt;function_foo&gt;\n"
msgstr ""

#: tut_tools.xml:100(para)
msgid ""
"The API documentation for most of the GLib, GObject, GTK+ and GNOME "
"libraries is built with a combination of complex tools. Typically, the part "
"of the documentation which describes the behavior of each function is "
"extracted from the specially-formatted source code comments by a tool named "
"gtk-doc which generates DocBook XML and merges this DocBook XML with a set "
"of master XML DocBook files. These XML DocBook files are finally processed "
"with xsltproc (a small program part of the libxslt library) to generate the "
"final HTML output. Other tools can be used to generate PDF output from the "
"source XML. The following code excerpt shows what these comments look like. "
"<placeholder-1/>"
msgstr ""

#: tut_tools.xml:109(programlisting)
#, no-wrap
msgid ""
"\n"
"/**\n"
" * gtk_widget_freeze_child_notify:\n"
" * @widget: a #GtkWidget\n"
" * \n"
" * Stops emission of \"child-notify\" signals on @widget. The signals are\n"
" * queued until gtk_widget_thaw_child_notify() is called on @widget. \n"
" *\n"
" * This is the analogue of g_object_freeze_notify() for child properties.\n"
" **/\n"
"void\n"
"gtk_widget_freeze_child_notify (GtkWidget *widget)\n"
"{\n"
"...\n"
"      "
msgstr ""

#: tut_tools.xml:125(para)
msgid ""
"Thorough <ulink url=\"http://library.gnome.org/devel/gtk-doc-manual/stable/"
"\">documentation</ulink> on how to set up and use gtk-doc in your project is "
"provided on the <ulink url=\"http://library.gnome.org/devel/\">GNOME "
"developer website</ulink>."
msgstr ""

#: tut_tools.xml:15(para)
msgid ""
"For example, writing GObjects is often seen as a tedious task. It requires a "
"lot of typing and just doing a copy/paste requires a great deal of care. A "
"lot of projects and scripts have been written to generate GObject skeleton "
"form boilerplate code, or even translating higher-level language into plain "
"C."
msgstr ""

#: tut_tools.xml:25(title)
msgid "Vala"
msgstr ""

#: tut_tools.xml:26(para)
msgid ""
"From the <ulink url=\"http://live.gnome.org/Vala\">Vala homepage</ulink> "
"itself: <quote>Vala is a new programming language that aims to bring modern "
"programming language features to GNOME developers without imposing any "
"additional runtime requirements and without using a different ABI compared "
"to applications and libraries written in C.</quote>"
msgstr ""

#: tut_tools.xml:35(para)
msgid ""
"The syntax of Vala is similar to C#. The available compiler translates Vala "
"into GObject C code. It can also compile non-GObject C, using plain C API."
msgstr ""

#: tut_tools.xml:43(title)
msgid "GObject builder"
msgstr ""

#: tut_tools.xml:45(para)
msgid ""
"In order to help a GObject class developper, one obvious idea is to use some "
"sort of templates for the skeletons. and then run them through a special "
"tool to generate the real C files. <ulink url=\"http://www.5z.com/jirka/gob."
"html\">GOB</ulink> (or GOB2) is such a tool. It is a preprocessor which can "
"be used to build GObjects with inline C code so that there is no need to "
"edit the generated C code. The syntax is inspired by Java and Yacc or Lex. "
"The implementation is intentionally kept simple: the inline C code provided "
"by the user is not parsed."
msgstr ""

#: tut_tools.xml:59(title)
msgid "Graphical inspection of GObjects"
msgstr ""

#: tut_tools.xml:6(title)
msgid "Related Tools"
msgstr ""

#: tut_tools.xml:61(para)
msgid ""
"Yet another tool that you may find helpful when working with GObjects is "
"<ulink url=\"http://sourceforge.net/projects/g-inspector\">G-Inspector</"
"ulink>. It is able to display GLib/GTK+ objects and their properties."
msgstr ""

#: tut_tools.xml:70(title)
msgid "Debugging reference count problems"
msgstr ""

#: tut_tools.xml:72(para)
msgid ""
"The reference counting scheme used by GObject does solve quite a few memory "
"management problems but also introduces new sources of bugs. In large "
"applications, finding the exact spot where the reference count of an Object "
"is not properly handled can be very difficult. Hopefully, there exist a tool "
"named <ulink url=\"http://refdbg.sf.net/\">refdbg</ulink> which can be used "
"to automate the task of tracking down the location of invalid code with "
"regard to reference counting. This application intercepts the reference "
"counting calls and tries to detect invalid behavior. It supports a filter-"
"rule mechanism to let you trace only the objects you are interested in and "
"it can be used together with GDB."
msgstr ""

#: tut_tools.xml:84(para)
msgid ""
"<indexterm><primary>g_trap_object_ref</primary></indexterm> Note that if "
"GObject has been compiled with <option>--enable-debug=yes</option>, it "
"exports a trap variable <placeholder-1/> If set to a non-NULL value, <link "
"linkend=\"g-object-ref\">g_object_ref</link>() and <link linkend=\"g-object-"
"unref\">g_object_unref</link>() will be intercepted when called with that "
"value."
msgstr ""

#: tut_tools.xml:88(programlisting)
#, no-wrap
msgid ""
"\n"
"static volatile GObject *g_trap_object_ref;\n"
"      "
msgstr ""

#: tut_tools.xml:9(para)
msgid ""
"Several useful developer tools have been build around GObject technology. "
"The next sections briefly introduce them and link to the respective project "
"pages."
msgstr ""

#: tut_tools.xml:98(title)
msgid "Writing API docs"
msgstr ""
