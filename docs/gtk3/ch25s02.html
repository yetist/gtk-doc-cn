<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Changes that need to be done at the time of the switch</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="GTK+ 3 参考手册">
<link rel="up" href="gtk-migrating-2-to-3.html" title="Migrating from GTK+ 2.x to GTK+ 3">
<link rel="prev" href="gtk-migrating-2-to-3.html" title="Migrating from GTK+ 2.x to GTK+ 3">
<link rel="next" href="gtk-migrating-GtkApplication.html" title="Migrating from libunique to GApplication or GtkApplication">
<meta name="generator" content="GTK-Doc V1.17 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2"><tr valign="middle">
<td><a accesskey="p" href="gtk-migrating-2-to-3.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="gtk-migrating-2-to-3.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">GTK+ 3 参考手册</th>
<td><a accesskey="n" href="gtk-migrating-GtkApplication.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr></table>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="id3658719"></a>Changes that need to be done at the time of the switch</h3></div></div></div>
<p>
    This section outlines porting tasks that you need to tackle when
    you get to the point that you actually build your application against
    GTK+ 3. Making it possible to prepare for these in GTK+ 2.24 would
    have been either impossible or impractical.
  </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3726502"></a>Replace size_request by get_preferred_width/height</h4></div></div></div>
<p>
      The request-phase of the traditional GTK+ geometry management
      has been replaced by a more flexible height-for-width system,
      which is described in detail in the API documentation
      (see <a class="xref" href="gtk3-GtkWidget.html#geometry-management" title="Height-for-width Geometry Management">the section called “Height-for-width Geometry Management”</a>). As a consequence,
      the ::size-request signal and vfunc has been removed from
      <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass" title="struct GtkWidgetClass"><span class="type">GtkWidgetClass</span></a>. The replacement for <code class="function">size_request()</code> can
      take several levels of sophistication:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
        As a minimal replacement to keep current functionality,
        you can simply implement the <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-width"><code class="function">GtkWidgetClass.get_preferred_width()</code></a> and
        <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-height"><code class="function">GtkWidgetClass.get_preferred_height()</code></a> vfuncs by calling your existing
        <code class="function">size_request()</code> function. So you go from
        </p>
<div class="informalexample"><pre class="programlisting">
static void
my_widget_class_init (MyWidgetClass *class)
{
  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);

  /* ... */

  widget_class-&gt;size_request = my_widget_size_request;

  /* ... */
}
        </pre></div>
<p>
        </p>
<p>
        to something that looks more like this:
        </p>
<p>
        </p>
<div class="informalexample"><pre class="programlisting">
static void
my_widget_get_preferred_width (GtkWidget *widget,
                               gint      *minimal_width,
                               gint      *natural_width)
{
  GtkRequisition requisition;

  my_widget_size_request (widget, &amp;requisition);

  *minimal_width = *natural_width = requisition.width;
}

static void
my_widget_get_preferred_height (GtkWidget *widget,
                                gint      *minimal_height,
                                gint      *natural_height)
{
  GtkRequisition requisition;

  my_widget_size_request (widget, &amp;requisition);

  *minimal_height = *natural_height = requisition.height;
}

 /* ... */

static void
my_widget_class_init (MyWidgetClass *class)
{
  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);

  /* ... */

  widget_class-&gt;get_preferred_width = my_widget_get_preferred_width;
  widget_class-&gt;get_preferred_height = my_widget_get_preferred_height;

  /* ... */

}
        </pre></div>
<p>
          </p>
<p>
          Sometimes you can make things a little more streamlined
          by replacing your existing <code class="function">size_request()</code> implementation by
          one that takes an orientation parameter:
          </p>
<p>
          </p>
<div class="informalexample"><pre class="programlisting">
static void
my_widget_get_preferred_size (GtkWidget      *widget,
                              GtkOrientation  orientation,
                               gint          *minimal_size,
                               gint          *natural_size)
{

  /* do things that are common for both orientations ... */

  if (orientation == GTK_ORIENTATION_HORIZONTAL)
    {
      /* do stuff that only applies to width... */

      *minimal_size = *natural_size = ...
    }
  else
   {
      /* do stuff that only applies to height... */

      *minimal_size = *natural_size = ...
   }
}

static void
my_widget_get_preferred_width (GtkWidget *widget,
                               gint      *minimal_width,
                               gint      *natural_width)
{
  my_widget_get_preferred_size (widget,
                                GTK_ORIENTATION_HORIZONTAL,
                                minimal_width,
                                natural_width);
}

static void
my_widget_get_preferred_height (GtkWidget *widget,
                                gint      *minimal_height,
                                gint      *natural_height)
{
  my_widget_get_preferred_size (widget,
                                GTK_ORIENTATION_VERTICAL,
                                minimal_height,
                                natural_height);
}

 /* ... */
          </pre></div>
<p>
          </p>
</li>
<li class="listitem">
<p>If your widget can cope with a small size,
          but would appreciate getting some more space (a common
          example would be that it contains ellipsizable labels),
          you can do that by making your <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-width"><code class="function">GtkWidgetClass.get_preferred_width()</code></a> /
          <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-height"><code class="function">GtkWidgetClass.get_preferred_height()</code></a>
          functions return a smaller value for <em class="parameter"><code>minimal</code></em> than for <em class="parameter"><code>natural</code></em>.
          For <em class="parameter"><code>minimal</code></em>, you probably want to return the same value
          that your <code class="function">size_request()</code> function returned before (since
          <code class="function">size_request()</code> was defined as returning the minimal size
          a widget can work with). A simple way to obtain good
          values for <em class="parameter"><code>natural</code></em>, in the case of containers, is to use
          <a class="link" href="gtk3-GtkWidget.html#gtk-widget-get-preferred-width" title="gtk_widget_get_preferred_width ()"><code class="function">gtk_widget_get_preferred_width()</code></a> and
          <a class="link" href="gtk3-GtkWidget.html#gtk-widget-get-preferred-height" title="gtk_widget_get_preferred_height ()"><code class="function">gtk_widget_get_preferred_height()</code></a> on the children of the
          container, as in the following example:
          </p>
<div class="informalexample"><pre class="programlisting">
static void
gtk_fixed_get_preferred_height (GtkWidget *widget,
                                gint      *minimum,
                                gint      *natural)
{
  GtkFixed *fixed = GTK_FIXED (widget);
  GtkFixedPrivate *priv = fixed-&gt;priv;
  GtkFixedChild *child;
  GList *children;
  gint child_min, child_nat;

  *minimum = 0;
  *natural = 0;

  for (children = priv-&gt;children; children; children = children-&gt;next)
    {
      child = children-&gt;data;

      if (!gtk_widget_get_visible (child-&gt;widget))
        continue;

      gtk_widget_get_preferred_height (child-&gt;widget, &amp;child_min, &amp;child_nat);

      *minimum = MAX (*minimum, child-&gt;y + child_min);
      *natural = MAX (*natural, child-&gt;y + child_nat);
    }
}
          </pre></div>
<p>
          </p>
</li>
<li class="listitem"><p>
          Note that the <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-width"><code class="function">GtkWidgetClass.get_preferred_width()</code></a> /
          <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-height"><code class="function">GtkWidgetClass.get_preferred_height()</code></a> functions
          only allow you to deal with one dimension at a time. If your
          <code class="function">size_request()</code> handler is doing things that involve both
          width and height at the same time (e.g. limiting the aspect
          ratio), you will have to implement
          <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-height-for-width"><code class="function">GtkWidgetClass.get_preferred_height_for_width()</code></a>
          and <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-width-for-height"><code class="function">GtkWidgetClass.get_preferred_width_for_height()</code></a>.
          </p></li>
<li class="listitem"><p>
          To make full use of the new capabilities of the
          height-for-width geometry management, you need to additionally
          implement the <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-height-for-width"><code class="function">GtkWidgetClass.get_preferred_height_for_width()</code></a> and
          <a class="link" href="gtk3-GtkWidget.html#GtkWidgetClass.get-preferred-width-for-height"><code class="function">GtkWidgetClass.get_preferred_width_for_height()</code></a>. For details on
          these functions, see <a class="xref" href="gtk3-GtkWidget.html#geometry-management" title="Height-for-width Geometry Management">the section called “Height-for-width Geometry Management”</a>.
          </p></li>
</ul></div>
<p>
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3716527"></a>Replace GdkRegion by cairo_region_t</h4></div></div></div>
<p>
      Starting with version 1.10, cairo provides a region API that is
      equivalent to the GDK region API (which was itself copied from
      the X server). Therefore, the region API has been removed in GTK+ 3.
    </p>
<p>
      Porting your application to the cairo region API should be a straight
      find-and-replace task. Please refer to the following table:
      </p>
<div class="table">
<a name="id3716546"></a><p class="title"><b>Table 1. </b></p>
<div class="table-contents"><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>GDK</th>
<th>cairo</th>
</tr></thead>
<tbody>
<tr>
<td><span class="type">GdkRegion</span></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-t"><span class="type">cairo_region_t</span></a></td>
</tr>
<tr>
<td><a href="../gdk3/gdk3-Points-Rectangles-and-Regions.html#GdkRectangle"><span class="type">GdkRectangle</span></a></td>
<td><a href="../cairo/cairo-Types.html#cairo-rectangle-int-t"><span class="type">cairo_rectangle_int_t</span></a></td>
</tr>
<tr>
<td><a href="../gdk3/gdk3-Points-Rectangles-and-Regions.html#gdk-rectangle-intersect"><code class="function">gdk_rectangle_intersect()</code></a></td>
<td>this function is still there</td>
</tr>
<tr>
<td><a href="../gdk3/gdk3-Points-Rectangles-and-Regions.html#gdk-rectangle-union"><code class="function">gdk_rectangle_union()</code></a></td>
<td>this function is still there</td>
</tr>
<tr>
<td><code class="function">gdk_region_new()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-create"><code class="function">cairo_region_create()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_copy()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-copy"><code class="function">cairo_region_copy()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_destroy()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-destroy"><code class="function">cairo_region_destroy()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_rectangle()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-create-rectangle"><code class="function">cairo_region_create_rectangle()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_get_clipbox()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-get-extents"><code class="function">cairo_region_get_extents()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_get_rectangles()</code></td>
<td>
<a href="../cairo/cairo-Regions.html#cairo-region-num-rectangles"><code class="function">cairo_region_num_rectangles()</code></a> and
                                <a href="../cairo/cairo-Regions.html#cairo-region-get-rectangle"><code class="function">cairo_region_get_rectangle()</code></a>
</td>
</tr>
<tr>
<td><code class="function">gdk_region_empty()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-is-empty"><code class="function">cairo_region_is_empty()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_equal()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-equal"><code class="function">cairo_region_equal()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_point_in()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-contains-point"><code class="function">cairo_region_contains_point()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_rect_in()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-contains-rectangle"><code class="function">cairo_region_contains_rectangle()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_offset()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-translate"><code class="function">cairo_region_translate()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_union_with_rect()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-union-rectangle"><code class="function">cairo_region_union_rectangle()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_intersect()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-intersect"><code class="function">cairo_region_intersect()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_union()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-union"><code class="function">cairo_region_union()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_subtract()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-subtract"><code class="function">cairo_region_subtract()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_xor()</code></td>
<td><a href="../cairo/cairo-Regions.html#cairo-region-xor"><code class="function">cairo_region_xor()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_region_shrink()</code></td>
<td>no replacement</td>
</tr>
<tr>
<td><code class="function">gdk_region_polygon()</code></td>
<td>no replacement, use cairo paths instead</td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724173"></a>Replace GdkPixmap by cairo surfaces</h4></div></div></div>
<p>
      The <span class="type">GdkPixmap</span> object and related functions have been removed.
      In the cairo-centric world of GTK+ 3, cairo surfaces take over
      the role of pixmaps.
    </p>
<div class="example">
<a name="id3724192"></a><p class="title"><b>Example 95. Creating custom cursors</b></p>
<div class="example-contents">
<p>
        One place where pixmaps were commonly used is to create custom
        cursors:
      </p>
<div class="informalexample"><pre class="programlisting">
GdkCursor *cursor;
GdkPixmap *pixmap;
cairo_t *cr;
GdkColor fg = { 0, 0, 0, 0 };

pixmap = gdk_pixmap_new (NULL, 1, 1, 1);

cr = gdk_cairo_create (pixmap);
cairo_rectangle (cr, 0, 0, 1, 1);
cairo_fill (cr);
cairo_destroy (cr);

cursor = gdk_cursor_new_from_pixmap (pixmap, pixmap, &amp;fg, &amp;fg, 0, 0);

g_object_unref (pixmap);
      </pre></div>
<p>
      The same can be achieved without pixmaps, by drawing onto
      an image surface:
      </p>
<div class="informalexample"><pre class="programlisting">
GdkCursor *cursor;
cairo_surface_t *s;
cairo_t *cr;
GdkPixbuf *pixbuf;

s = cairo_image_surface_create (CAIRO_FORMAT_A1, 3, 3);
cr = cairo_create (s);
cairo_arc (cr, 1.5, 1.5, 1.5, 0, 2 * M_PI);
cairo_fill (cr);
cairo_destroy (cr);

pixbuf = gdk_pixbuf_get_from_surface (NULL, s,
                                      0, 0, 0, 0,
                                      3, 3);

cairo_surface_destroy (s);

cursor = gdk_cursor_new_from_pixbuf (display, pixbuf, 0, 0);

g_object_unref (pixbuf);
      </pre></div>
<p>
      </p>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724237"></a>Replace GdkColormap by GdkVisual</h4></div></div></div>
<p>
      For drawing with cairo, it is not necessary to allocate colors, and
      a <a href="../gdk3/gdk3-Visuals.html#GdkVisual"><span class="type">GdkVisual</span></a> provides enough information for cairo to handle colors
      in 'native' surfaces. Therefore, <span class="type">GdkColormap</span> and related functions
      have been removed in GTK+ 3, and visuals are used instead. The
      colormap-handling functions of <a class="link" href="gtk3-GtkWidget.html#GtkWidget" title="GtkWidget"><span class="type">GtkWidget</span></a> (<code class="function">gtk_widget_set_colormap()</code>,
      etc) have been removed and <a class="link" href="gtk3-GtkWidget.html#gtk-widget-set-visual" title="gtk_widget_set_visual ()"><code class="function">gtk_widget_set_visual()</code></a> has been added.
    </p>
<div class="example">
<a name="id3724293"></a><p class="title"><b>Example 96. Setting up a translucent window</b></p>
<div class="example-contents">
<p>You might have a screen-changed handler like the following
     to set up a translucent window with an alpha-channel:
    </p>
<div class="informalexample"><pre class="programlisting">
static void
on_alpha_screen_changed (GtkWidget *widget,
                         GdkScreen *old_screen,
                         GtkWidget *label)
{
  GdkScreen *screen = gtk_widget_get_screen (widget);
  GdkColormap *colormap = gdk_screen_get_rgba_colormap (screen);

  if (colormap == NULL)
    colormap = gdk_screen_get_default_colormap (screen);

  gtk_widget_set_colormap (widget, colormap);
}
    </pre></div>
<p>
    With visuals instead of colormaps, this will look as follows:
    </p>
<div class="informalexample"><pre class="programlisting">
static void
on_alpha_screen_changed (GtkWindow *window,
                         GdkScreen *old_screen,
                         GtkWidget *label)
{
  GdkScreen *screen = gtk_widget_get_screen (GTK_WIDGET (window));
  GdkVisual *visual = gdk_screen_get_rgba_visual (screen);

  if (visual == NULL)
    visual = gdk_screen_get_system_visual (screen);

  gtk_widget_set_visual (window, visual);
}
    </pre></div>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724341"></a>GdkDrawable is gone</h4></div></div></div>
<p>
      <span class="type">GdkDrawable</span> has been removed in GTK+ 3, together with <span class="type">GdkPixmap</span>
      and <span class="type">GdkImage</span>. The only remaining drawable class is <a href="../gdk3/gdk3-Windows.html#GdkWindow"><span class="type">GdkWindow</span></a>.
      For dealing with image data, you should use a <a href="../cairo/cairo-cairo-surface-t.html#cairo-surface-t"><span class="type">cairo_surface_t</span></a> or
      a <a href="../gdk-pixbuf/gdk-pixbuf-The-GdkPixbuf-Structure.html#GdkPixbuf"><span class="type">GdkPixbuf</span></a>.
    </p>
<p>
      GdkDrawable functions that are useful with windows have been replaced
      by corresponding GdkWindow functions:
      </p>
<div class="table">
<a name="id3724398"></a><p class="title"><b>Table 2. GdkDrawable to GdkWindow</b></p>
<div class="table-contents"><table summary="GdkDrawable to GdkWindow" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>GDK 2.x</th>
<th>GDK 3</th>
</tr></thead>
<tbody>
<tr>
<td><code class="function">gdk_drawable_get_visual()</code></td>
<td><a href="../gdk3/gdk3-Windows.html#gdk-window-get-visual"><code class="function">gdk_window_get_visual()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_drawable_get_size()</code></td>
<td>
<a href="../gdk3/gdk3-Windows.html#gdk-window-get-width"><code class="function">gdk_window_get_width()</code></a>
                                                              <a href="../gdk3/gdk3-Windows.html#gdk-window-get-height"><code class="function">gdk_window_get_height()</code></a>
</td>
</tr>
<tr>
<td><code class="function">gdk_pixbuf_get_from_drawable()</code></td>
<td><a href="../gdk3/gdk3-Pixbufs.html#gdk-pixbuf-get-from-window"><code class="function">gdk_pixbuf_get_from_window()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_drawable_get_clip_region()</code></td>
<td><a href="../gdk3/gdk3-Windows.html#gdk-window-get-clip-region"><code class="function">gdk_window_get_clip_region()</code></a></td>
</tr>
<tr>
<td><code class="function">gdk_drawable_get_visible_region()</code></td>
<td><a href="../gdk3/gdk3-Windows.html#gdk-window-get-visible-region"><code class="function">gdk_window_get_visible_region()</code></a></td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724554"></a>Event filtering</h4></div></div></div>
<p>
      If your application uses the low-level event filtering facilities in GDK,
      there are some changes you need to be aware of.
    </p>
<p>
      The special-purpose GdkEventClient events and the <code class="function">gdk_add_client_message_filter()</code> and <code class="function">gdk_display_add_client_message_filter()</code> functions have been
      removed. Receiving X11 ClientMessage events is still possible, using
      the general <a href="../gdk3/gdk3-Windows.html#gdk-window-add-filter"><code class="function">gdk_window_add_filter()</code></a> API. A client message filter like
</p>
<div class="informalexample"><pre class="programlisting">
static GdkFilterReturn
message_filter (GdkXEvent *xevent, GdkEvent *event, gpointer data)
{
  XClientMessageEvent *evt = (XClientMessageEvent *)xevent;

  /* do something with evt ... */
}

 ...

message_type = gdk_atom_intern ("MANAGER", FALSE);
gdk_display_add_client_message_filter (display, message_type, message_filter, NULL);
</pre></div>
<p>
    then looks like this:
    </p>
<div class="informalexample"><pre class="programlisting">
static GdkFilterReturn
event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer data)
{
  XClientMessageEvent *evt;
  GdkAtom message_type;

  if (((XEvent *)xevent)-&gt;type != ClientMessage)
    return GDK_FILTER_CONTINUE;

  evt = (XClientMessageEvent *)xevent;
  message_type = XInternAtom (evt-&gt;display, "MANAGER", FALSE);

  if (evt-&gt;message_type != message_type)
    return GDK_FILTER_CONTINUE;

  /* do something with evt ... */
}

 ...

gdk_window_add_filter (NULL, message_filter, NULL);
</pre></div>
<p>
      One advantage of using an event filter is that you can actually
      remove the filter when you don't need it anymore, using
      <a href="../gdk3/gdk3-Windows.html#gdk-window-remove-filter"><code class="function">gdk_window_remove_filter()</code></a>.
    </p>
<p>
      The other difference to be aware of when working with event filters
      in GTK+ 3 is that GDK now uses XI2 by default when available. That
      means that your application does not receive core X11 key or button
      events. Instead, all input events are delivered as XIDeviceEvents.
      As a short-term workaround for this, you can force your application
      to not use XI2, with <a href="../gdk3/GdkDeviceManager.html#gdk-disable-multidevice"><code class="function">gdk_disable_multidevice()</code></a>. In the long term,
      you probably want to rewrite your event filter to deal with
      XIDeviceEvents.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724668"></a>Backend-specific code</h4></div></div></div>
<p>
      In GTK+ 2.x, GDK could only be compiled for one backend at a time,
      and the <a href="../gdk3/gdk3-General.html#GDK-WINDOWING-X11:CAPS"><code class="literal">GDK_WINDOWING_X11</code></a> or <a href="../gdk3/gdk3-General.html#GDK-WINDOWING-WIN32:CAPS"><code class="literal">GDK_WINDOWING_WIN32</code></a> macros could
      be used to find out which one you are dealing with:
      </p>
<div class="informalexample"><pre class="programlisting">
#ifdef GDK_WINDOWING_X11
      if (timestamp != GDK_CURRENT_TIME)
        gdk_x11_window_set_user_time (gdk_window, timestamp);
#endif
#ifdef GDK_WINDOWING_WIN32
        /* ... win32 specific code ... */
#endif
      </pre></div>
<p>
      In GTK+ 3, GDK can be built with multiple backends, and currently
      used backend has to be determined at runtime, typically using
      type-check macros on a <a href="../gdk3/GdkDisplay.html"><span class="type">GdkDisplay</span></a> or <a href="../gdk3/gdk3-Windows.html#GdkWindow"><span class="type">GdkWindow</span></a>. You still need
      to use the <span class="type">GDK_WINDOWING</span> macros to only compile code referring
      to supported backends:
      </p>
<div class="informalexample"><pre class="programlisting">
#ifdef GDK_WINDOWING_X11
      if (GDK_IS_X11_DISPLAY (display))
        {
          if (timestamp != GDK_CURRENT_TIME)
            gdk_x11_window_set_user_time (gdk_window, timestamp);
        }
      else
#endif
#ifdef GDK_WINDOWING_WIN32
      if (GDK_IS_WIN32_DISPLAY (display))
        {
          /* ... win32 specific code ... */
        }
      else
#endif
       {
         g_warning ("Unsupported GDK backend");
       }
      </pre></div>
<p>
    </p>
<p>
      If you used the pkg-config variable <code class="varname">target</code> to
      conditionally build part of your project depending on the GDK backend,
      for instance like this:
      </p>
<div class="informalexample"><pre class="programlisting">
AM_CONDITIONAL(BUILD_X11, test `$PKG_CONFIG --variable=target gtk+-2.0` = "x11")
      </pre></div>
<p>
      then you should now use the M4 macro provided by GTK+ itself:
      </p>
<div class="informalexample"><pre class="programlisting">
GTK_CHECK_BACKEND([x11], [3.0.2], [have_x11=yes], [have_x11=no])
AM_CONDITIONAL(BUILD_x11, [test "x$have_x11" = "xyes"])
      </pre></div>
<p>
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724784"></a>GtkPlug and GtkSocket</h4></div></div></div>
<p>
      The <a class="link" href="gtk3-GtkPlug.html#GtkPlug" title="struct GtkPlug"><span class="type">GtkPlug</span></a> and <a class="link" href="gtk3-GtkSocket.html#GtkSocket" title="struct GtkSocket"><span class="type">GtkSocket</span></a> widgets are now X11-specific, and you
      have to include the <code class="filename">&lt;gtk/gtkx.h&gt;</code> header
      to use them. The previous section about proper handling of
      backend-specific code applies, if you care about other backends.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3724820"></a>The GtkWidget::draw signal</h4></div></div></div>
<p>
      The GtkWidget <span class="type">"expose-event"</span> signal has been replaced by
      a new <span class="type">"draw"</span> signal, which takes a <a href="../cairo/cairo-cairo-t.html#cairo-t"><span class="type">cairo_t</span></a> instead of
      an expose event. The cairo context is being set up so that the origin
      at (0, 0) coincides with the upper left corner of the widget, and
      is properly clipped.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>In other words, the cairo context of the draw signal is set
      up in 'widget coordinates', which is different from traditional expose
      event handlers, which always assume 'window coordinates'.
    </p>
</div>
<p>
      The widget is expected to draw itself with its allocated size, which
      is available via the new <a class="link" href="gtk3-GtkWidget.html#gtk-widget-get-allocated-width" title="gtk_widget_get_allocated_width ()"><code class="function">gtk_widget_get_allocated_width()</code></a> and
      <a class="link" href="gtk3-GtkWidget.html#gtk-widget-get-allocated-height" title="gtk_widget_get_allocated_height ()"><code class="function">gtk_widget_get_allocated_height()</code></a> functions. It is not necessary to
      check for <code class="function">GTK_WIDGET_IS_DRAWABLE()</code>, since GTK+ already does this check
      before emitting the <span class="type">"draw"</span> signal.
    </p>
<p>
      There are some special considerations for widgets with multiple windows.
      Expose events are window-specific, and widgets with multiple windows
      could expect to get an expose event for each window that needs to be
      redrawn. Therefore, multi-window expose event handlers typically look
      like this:
      </p>
<div class="informalexample"><pre class="programlisting">
      if (event-&gt;window == widget-&gt;window1)
        {
           /* ... draw window1 ... */
        }
      else if (event-&gt;window == widget-&gt;window2)
        {
           /* ... draw window2 ... */
        }
      ...
      </pre></div>
<p>
      In contrast, the <span class="type">"draw"</span> signal handler may have to draw multiple
      windows in one call. GTK+ has a convenience function
      <a class="link" href="gtk3-GtkWidget.html#gtk-cairo-should-draw-window" title="gtk_cairo_should_draw_window ()"><code class="function">gtk_cairo_should_draw_window()</code></a> that can be used to find out if
      a window needs to be drawn. With that, the example above would look
      like this (note that the 'else' is gone):
      </p>
<div class="informalexample"><pre class="programlisting">
      if (gtk_cairo_should_draw_window (cr, widget-&gt;window1)
        {
           /* ... draw window1 ... */
        }
      if (gtk_cairo_should_draw_window (cr, widget-&gt;window2)
        {
           /* ... draw window2 ... */
        }
      ...
      </pre></div>
<p>
      Another convenience function that can help when implementing
      ::draw for multi-window widgets is <a class="link" href="gtk3-GtkWidget.html#gtk-cairo-transform-to-window" title="gtk_cairo_transform_to_window ()"><code class="function">gtk_cairo_transform_to_window()</code></a>,
      which transforms a cairo context from widget-relative coordinates
      to window-relative coordinates.
    </p>
<p>
      All GtkStyle drawing functions (<a class="link" href="gtk3-GtkStyle.html#gtk-paint-box" title="gtk_paint_box ()"><code class="function">gtk_paint_box()</code></a>, etc) have been changed
      to take a <a href="../cairo/cairo-cairo-t.html#cairo-t"><span class="type">cairo_t</span></a> instead of a window and a clip area. ::draw
      implementations will usually just use the cairo context that has been
      passed in for this.
    </p>
<div class="example">
<a name="id3725000"></a><p class="title"><b>Example 97. A simple ::draw function</b></p>
<div class="example-contents"><pre class="programlisting">
gboolean
gtk_arrow_draw (GtkWidget *widget,
                cairo_t   *cr)
{
  GtkStyleContext *context;
  gint x, y;
  gint width, height;
  gint extent;

  context = gtk_widget_get_style_context (widget);

  width = gtk_widget_get_allocated_width (widget);
  height = gtk_widget_get_allocated_height (widget);

  extent = MIN (width - 2 * PAD, height - 2 * PAD);
  x = PAD;
  y = PAD;

  gtk_render_arrow (context, rc, G_PI / 2, x, y, extent);
}
    </pre></div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725022"></a>GtkProgressBar orientation</h4></div></div></div>
<p>
      In GTK+ 2.x, <a class="link" href="gtk3-GtkProgressBar.html#GtkProgressBar" title="struct GtkProgressBar"><span class="type">GtkProgressBar</span></a> and <a class="link" href="gtk3-GtkCellRendererProgress.html#GtkCellRendererProgress" title="struct GtkCellRendererProgress"><span class="type">GtkCellRendererProgress</span></a> were using the
      GtkProgressBarOrientation enumeration to specify their orientation and
      direction. In GTK+ 3, both the widget and the cell renderer implement
      <a class="link" href="gtk3-Orientable.html#GtkOrientable" title="GtkOrientable"><span class="type">GtkOrientable</span></a>, and have an additional 'inverted' property to determine
      their direction. Therefore, a call to <code class="function">gtk_progress_bar_set_orientation()</code>
      needs to be replaced by a pair of calls to
      <a class="link" href="gtk3-Orientable.html#gtk-orientable-set-orientation" title="gtk_orientable_set_orientation ()"><code class="function">gtk_orientable_set_orientation()</code></a> and <a class="link" href="gtk3-GtkProgressBar.html#gtk-progress-bar-set-inverted" title="gtk_progress_bar_set_inverted ()"><code class="function">gtk_progress_bar_set_inverted()</code></a>.
      The following values correspond:
      </p>
<div class="table">
<a name="id3725090"></a><p class="title"><b>Table 3. </b></p>
<div class="table-contents"><table border="1">
<colgroup>
<col class="1">
<col class="2">
<col class="3">
</colgroup>
<thead>
<tr>
<th>GTK+ 2.x</th>
<th colspan="2">GTK+ 3</th>
</tr>
<tr>
<th>GtkProgressBarOrientation</th>
<th>GtkOrientation</th>
<th>inverted</th>
</tr>
</thead>
<tbody>
<tr>
<td>GTK_PROGRESS_LEFT_TO_RIGHT</td>
<td>GTK_ORIENTATION_HORIZONTAL</td>
<td>FALSE</td>
</tr>
<tr>
<td>GTK_PROGRESS_RIGHT_TO_LEFT</td>
<td>GTK_ORIENTATION_HORIZONTAL</td>
<td>TRUE</td>
</tr>
<tr>
<td>GTK_PROGRESS_TOP_TO_BOTTOM</td>
<td>GTK_ORIENTATION_VERTICAL</td>
<td>FALSE</td>
</tr>
<tr>
<td>GTK_PROGRESS_BOTTOM_TO_TOP</td>
<td>GTK_ORIENTATION_VERTICAL</td>
<td>TRUE</td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725182"></a>Check your expand and fill flags</h4></div></div></div>
<p>
      The behaviour of expanding widgets has changed slightly in GTK+ 3,
      compared to GTK+ 2.x. It is now 'inherited', i.e. a container that
      has an expanding child is considered expanding itself. This is often
      the desired behaviour. In places where you don't want this to happen,
      setting the container explicity as not expanding will stop the
      expand flag of the child from being inherited. See
      <a class="link" href="gtk3-GtkWidget.html#gtk-widget-set-hexpand" title="gtk_widget_set_hexpand ()"><code class="function">gtk_widget_set_hexpand()</code></a> and <a class="link" href="gtk3-GtkWidget.html#gtk-widget-set-vexpand" title="gtk_widget_set_vexpand ()"><code class="function">gtk_widget_set_vexpand()</code></a>.
    </p>
<p>
      If you experience sizing problems with widgets in ported code,
      carefully check the <span class="type">"expand"</span> and <span class="type">"fill"</span> flags of your
      boxes.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725240"></a>Scrolling changes</h4></div></div></div>
<p>
      The default values for the <span class="type">"hscrollbar-policy"</span> and
      <span class="type">"vscrollbar-policy"</span> properties have been changed from
      'never' to 'automatic'. If your application was relying on the default
      value, you will have explicitly set it explicitly.
    </p>
<p>
      The ::set-scroll-adjustments signal on GtkWidget has been replaced
      by the <a class="link" href="gtk3-GtkScrollable.html#GtkScrollable" title="GtkScrollable"><span class="type">GtkScrollable</span></a> interface which must be implemented by a widget
      that wants to be placed in a <a class="link" href="gtk3-GtkScrolledWindow.html#GtkScrolledWindow" title="struct GtkScrolledWindow"><span class="type">GtkScrolledWindow</span></a>. Instead of emitting
      ::set-scroll-adjustments, the scrolled window simply sets the
      <span class="type">"hadjustment"</span> and <span class="type">"vadjustment"</span> properties.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725305"></a>GtkObject is gone</h4></div></div></div>
<p>
      GtkObject has been removed in GTK+ 3. Its remaining functionality,
      the ::destroy signal, has been moved to GtkWidget. If you have non-widget
      classes that are directly derived from GtkObject, you have to make
      them derive from <a href="../gobject/gobject-The-Base-Object-Type.html#GInitiallyUnowned"><span class="type">GInitiallyUnowned</span></a> (or, if you don't need the floating
      functionality, <a href="../gobject/gobject-The-Base-Object-Type.html#GObject"><span class="type">GObject</span></a>). If you have widgets that override the
      destroy class handler, you have to adjust your class_init function,
      since destroy is now a member of GtkWidgetClass:
      </p>
<div class="informalexample"><pre class="programlisting">
      GtkObjectClass *object_class = GTK_OBJECT_CLASS (class);

      object_class-&gt;destroy = my_destroy;
      </pre></div>
<p>
      becomes
      </p>
<div class="informalexample"><pre class="programlisting">
      GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);

      widget_class-&gt;destroy = my_destroy;
      </pre></div>
<p>
      In the unlikely case that you have a non-widget class that is derived
      from GtkObject and makes use of the destroy functionality, you have
      to implement ::destroy yourself.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725361"></a>GtkEntryCompletion signal parameters</h4></div></div></div>
<p>
      The <span class="type">"match-selected"</span> and
      <span class="type">"cursor-on-match"</span> signals were erroneously
      given the internal filter model instead of the users model.
      This oversight has been fixed in GTK+ 3; if you have handlers
      for these signals, they will likely need slight adjustments.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725391"></a>Resize grips</h4></div></div></div>
<p>
     The resize grip functionality has been moved from <a class="link" href="gtk3-GtkStatusbar.html#GtkStatusbar" title="struct GtkStatusbar"><span class="type">GtkStatusbar</span></a>
     to <a class="link" href="gtk3-GtkWindow.html#GtkWindow" title="GtkWindow"><span class="type">GtkWindow</span></a>. Any window can now have resize grips, regardless whether
     it has a statusbar or not. The functions
     <code class="function">gtk_statusbar_set_has_resize_grip()</code> and <code class="function">gtk_statusbar_get_has_resize_grip()</code>
     have disappeared, and instead there are now
     <a class="link" href="gtk3-GtkWindow.html#gtk-window-set-has-resize-grip" title="gtk_window_set_has_resize_grip ()"><code class="function">gtk_window_set_has_resize_grip()</code></a> and <a class="link" href="gtk3-GtkWindow.html#gtk-window-get-has-resize-grip" title="gtk_window_get_has_resize_grip ()"><code class="function">gtk_window_get_has_resize_grip()</code></a>.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725464"></a>Prevent mixed linkage</h4></div></div></div>
<p>
      Linking against GTK+ 2.x and GTK+ 3 in the same process is problematic
      and can lead to hard-to-diagnose crashes. The <a class="link" href="gtk3-General.html#gtk-init" title="gtk_init ()"><code class="function">gtk_init()</code></a> function in
      both GTK+ 2.22 and in GTK+ 3 tries to detect this situation and abort
      with a diagnostic message, but this check is not 100% reliable (e.g. if
      the problematic linking happens only in loadable modules).
    </p>
<p>
      Direct linking of your application against both versions of GTK+ is
      easy to avoid; the problem gets harder when your application is using
      libraries that are themselves linked against some version of GTK+.
      In that case, you have to verify that you are using a version of the
      library that is linked against GTK+ 3.
    </p>
<p>
      If you are using packages provided by a distributor, it is likely that
      parallel installable versions of the library exist for GTK+ 2.x and
      GTK+ 3, e.g for vte, check for vte3; for webkitgtk look for webkitgtk3,
      and so on.
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="id3725508"></a>Install GTK+ modules in the right place</h4></div></div></div>
<p>
    Some software packages install loadable GTK+ modules such as theme engines,
    gdk-pixbuf loaders or input methods. Since GTK+ 3 is parallel-installable
    with GTK+ 2.x, the two GTK+ versions have separate locations for their
    loadable modules. The location for GTK+ 2.x is
    <code class="filename"><em class="replaceable"><code>libdir</code></em>/gtk-2.0</code>
    (and its subdirectories), for GTK+ 3 the location is
    <code class="filename"><em class="replaceable"><code>libdir</code></em>/gtk-3.0</code>
    (and its subdirectories).
  </p>
<p>
    For some kinds of modules, namely input methods and pixbuf loaders,
    GTK+ keeps a cache file with extra information about the modules.
    For GTK+ 2.x, these cache files are located in
    <code class="filename"><em class="replaceable"><code>sysconfdir</code></em>/gtk-2.0</code>.
    For GTK+ 3, they have been moved to
    <code class="filename"><em class="replaceable"><code>libdir</code></em>/gtk-3.0/3.0.0/</code>.
    The commands that create these cache files have been renamed with a -3
    suffix to make them parallel-installable.
  </p>
<p>
    Note that GTK+ modules often link against libgtk, libgdk-pixbuf, etc.
    If that is the case for your module, you have to be careful to link the
    GTK+ 2.x version of your module against the 2.x version of the libraries,
    and the GTK+ 3 version against hte 3.x versions. Loading a module linked
    against libgtk 2.x into an application using GTK+ 3 will lead to
    unhappiness and must be avoided.
  </p>
</div>
<span style="color: red">&lt;include&gt;&lt;/include&gt;</span>
</div>
<div class="footer">
<hr>
          Generated by GTK-Doc V1.17</div>
</body>
</html>